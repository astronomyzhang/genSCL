# example 1
requirement: {"title": "双字边沿检测", "description": "编写一个函数块FB，该函数块每周期检查一个双字（DWord）输入值中的每一位的上升沿和下降沿。函数块应能够检测并报告输入值中的变化、上升边沿和下降边沿。\n\n示例：\n假设输入值从2#101变为2#11011，则上升沿数量为3，上升边沿的位流为2#11010，下降沿数量为1，下降边沿的位流为2#100。", "type": "FUNCTION_BLOCK", "name": "GetBitStates", "input": [{"name": "value", "type": "DWord", "description": "待检查变化和边沿触发的输入值"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "为True时表示输入值已改变"}, {"name": "hasRisingEdges", "type": "Bool", "description": "为True时表示输入值出现上升边沿"}, {"name": "risingBits", "type": "DWord", "description": "上升边沿的位流，其中每个位表示相应位置的输入值是否发生了上升沿（1表示有上升沿，0表示无上升沿）"}, {"name": "noOfRisingBits", "type": "USInt", "description": "输入值中的上升边沿数量"}, {"name": "hasFallingEdges", "type": "Bool", "description": "为True时表示输入值出现下降边沿"}, {"name": "fallingBits", "type": "DWord", "description": "下降边沿的位流，其中每个位表示相应位置的输入值是否发生了下降沿（1表示有下降沿，0表示无下降沿）"}, {"name": "noOfFallingBits", "type": "USInt", "description": "输入值中的下降边沿数量"}]}
SCL CODE: "FUNCTION_BLOCK \"GetBitStates\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      value : DWord;\n   END_VAR\n\n   VAR_OUTPUT \n      hasChanged  : Bool;\n      hasRisingEdges : Bool;\n      risingBits  : DWord;\n      noOfRisingBits  : USInt;\n      hasFallingEdges  : Bool;\n      fallingBits  : DWord;\n      noOfFallingBits  : USInt;\n   END_VAR\n\n   VAR \n      statPreviousValue  : DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempRisingResult : DWord;\n      tempNoRisingBits : DWord;\n      tempFallingResult : DWord;\n      tempNoFallingBits : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_EDGES : DWord;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //============================================================================\n\t  // Title:            GetBitStates\n\t  // Comment/Function: Check DWord for edges, falling as well as rising.  \n\t  //                   Returns the number of edges, DWords with edge bits and a bool if edge(s) exists.\n\t  //                   https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION PROGRAM LOGIC\n\t  // Get edges from input DWord and DWord from previous cycle\n\t  #tempRisingResult := #value AND NOT #statPreviousValue;\n\t  #tempFallingResult := NOT #value AND #statPreviousValue;\n\t  \n\t  // Store value for next cycle\n\t  #statPreviousValue := #value;\n\t  \n\t  // Copy edge result into work variable for counting the number of rising edges\n\t  #tempNoRisingBits := #tempRisingResult;\n\t  // Count number of rising edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 1) AND 16#55555555));\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 2) AND 16#33333333));\n\t  #tempNoRisingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\t  \n\t  // Copy edges result into work variable for counting the number of falling edges\n\t  #tempNoFallingBits := #tempFallingResult;\n\t  // Count number of falling edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 1) AND 16#55555555));\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 2) AND 16#33333333));\n\t  #tempNoFallingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\tEND_REGION PROGRAM LOGIC\n\t\n\tREGION OUTPUTS\n\t  #hasChanged := (#tempRisingResult > #ZERO_EDGES) OR (#tempFallingResult > #ZERO_EDGES);\n\t  #hasRisingEdges := #tempRisingResult > #ZERO_EDGES;\n\t  #risingBits := #tempRisingResult;\n\t  #noOfRisingBits := DWORD_TO_USINT(#tempNoRisingBits);\n\t  \n\t  #hasFallingEdges := #tempFallingResult > #ZERO_EDGES;\n\t  #fallingBits := #tempFallingResult;\n\t  #noOfFallingBits := DWORD_TO_USINT(#tempNoFallingBits);\n\t  \n\t  // ENO not needed, no error evaluation needed\n\t  ENO := FALSE;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK\n\n"
# example 2
requirement: {"title": "数据类型为DTL的日期时间转换为字符串", "description": "编写一个函数FC，该函数能够将数据类型为DTL的日期时间值转换为字符串，并按照自定义的分隔符输出。转换后的字符串格式应为YYYY<分隔符>MM<分隔符>DD<分隔符>HH:mm:ss.nnnnnnnn，其中<分隔符>为函数参数指定的字符。这里HH代表小时（24小时制），mm代表分钟，ss代表秒，nnnnnnnn代表纳秒。注意，分隔符不应用于时分秒纳秒之间。\n\n示例：\n假设输入的DTL日期时间为2023-09-17 12:34:56.123456789，自定义分隔符为-。\n函数应返回字符串\"2023-09-17 12:34:56.123456789\"作为转换结果。", "type": "FUNCTION", "name": "DTLToString_ISO", "input": [{"name": "date", "type": "DTL", "description": "数据类型为DTL的日期"}, {"name": "separator", "type": "Char", "description": "转换后的日期中年和月之间，以及月和日之间的分隔符"}], "return_value": [{"type": "String", "description": "转换后的日期字符串"}]}
SCL CODE: "FUNCTION \"DTLToString_ISO\" : String\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      \"date\"  : DTL;\n      separator : Char;\n   END_VAR\n\n   VAR_TEMP \n      tempString : String;\n      tempIndex : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_STRING : Word := 16#0000;\n      CONVERT_START_POSITION_YEAR : UInt := 1;\n      CONVERT_START_POSITION_MONTH : UInt := 6;\n      CONVERT_START_POSITION_DAY : UInt := 9;\n      CONVERT_START_POSITION_HOUR : UInt := 12;\n      CONVERT_START_POSITION_MINUTE : UInt := 15;\n      CONVERT_START_POSITION_SECOND : UInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : UInt := 21;\n      SEPARATOR_POSITION_YEAR_MONTH : UInt := 5;\n      SEPARATOR_POSITION_MONTH_DAY : UInt := 8;\n      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;\n      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;\n      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;\n      SEPARATOR_NANOSECOND : Char := '.';\n      SEPARATOR_TIME : Char := ':';\n      SEPARATOR_DATE : Char := '-';\n      REPLACE_NANOSECOND_COUNT : DInt := 8;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            DTLtoString_ISO\n\t  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in international format (YYYY MM DD…).\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempString := '';\n\tEND_REGION\n\t\n\tREGION CONVERTER\n\t  // Set format parameters for output string\n\t  // International ISO 8601\n\t  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  // Convert \"Value\" into \"String\" and place at the right position\n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.YEAR,\n\t           P      := #CONVERT_START_POSITION_YEAR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_YEAR,\n\t           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MONTH,\n\t           P      := #CONVERT_START_POSITION_MONTH,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.DAY,\n\t           P      := #CONVERT_START_POSITION_DAY,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.HOUR,\n\t           P      := #CONVERT_START_POSITION_HOUR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MINUTE,\n\t           P      := #CONVERT_START_POSITION_MINUTE,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.SECOND,\n\t           P      := #CONVERT_START_POSITION_SECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.NANOSECOND,\n\t           P      := #CONVERT_START_POSITION_NANOSECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_NANOSECOND,\n\t           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond\n\t  \n\t  // Place separators at the right position in the string\n\t  IF #separator = '' THEN\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #SEPARATOR_DATE;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #separator;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;\n\t  END_IF;\n\t  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;\n\t  \n\t  // Correcting the string, due to the conversion of a leading \"0\" value into a \"blank\".\n\t  // Replacing of \"blank\" by \"0\"\n\t  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MONTH] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_DAY] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_HOUR] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_SECOND] := '0';\n\t  END_IF;\n\t  \n\t  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO\n\t    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN\n\t      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';\n\t    ELSE\n\t      EXIT;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #DTLToString_ISO := #tempString;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n"
# example 3
requirement: {"title": "从字符数组中截取字符串", "description": "编写一个函数FC，该函数能够根据给定的起始字符串和结束字符串，从字符数组中截取符合要求的子字符串。\n\n1. 函数应遍历searchIn，查找textBefore首次出现的位置，然后查找随后出现的textAfter的位置。\n2. 如果找到了textBefore和textAfter，函数应截取这两个边界之间的字符串（不包括边界字符串本身），并返回这个子字符串。\n3. 如果textBefore或textAfter在searchIn中不存在，函数应返回特定的状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：输入参数searchIn不是字符数组或字节数组\n\n返回值表示查找的结果：\n- 16#0000：查找成功，头部字符和尾部字符均已找到\n- 16#9001：查找不成功，只找到了起始边界，未找到结束边界\n- 16#9002：查找不成功，起始边界未找到。\n\n示例：\n假设searchIn为\"This is a [sample] string with [multiple] boundaries.\"，textBefore为\"[\"，textAfter为\"]\"。函数应返回\"sample\"作为截取到的子字符串。", "type": "FUNCTION", "name": "ExtractStringFromCharArray", "input": [{"name": "textBefore", "type": "String", "description": "要截取的字符串的起始边界"}, {"name": "textAfter", "type": "String", "description": "要截取的字符串的结束边界"}], "output": [{"name": "extractedString", "type": "String", "description": "截取的字符串"}, {"name": "status", "type": "Word", "description": "状态代码，具体见说明"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "要在其中进行搜索的字符或字节数组"}], "return_value": [{"type": "Word", "description": "状态代码，具体见说明"}]}
SCL CODE: "FUNCTION \"ExtractStringFromCharArray\" : Word\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      textBefore : String;\n      textAfter : String;\n   END_VAR\n\n   VAR_OUTPUT \n      extractedString : String;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      searchIn : Variant;\n   END_VAR\n\n   VAR_TEMP \n      tempNumElements : UDInt;\n      tempPosInArray : DInt;\n      tempLenTextBefore : Int;\n      tempPosTextBefore : DInt;\n      tempLenTextAfter : Int;\n      tempPosTextAfter : Int;\n      tempString : String;\n   END_VAR\n\n   VAR CONSTANT \n      LEN_STRING : UInt := 254;\n      STATUS_TEXT_FOUND : Word := 16#0000;\n      WARNING_ONLY_START : Word := 16#9001;\n      WARNING_NOTHING_FOUND : Word := 16#9002;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            ExtractStringFromCharArray\n\t  // Function:         The function extracts a String specified by a text before and after\n\t  //                   from an array of characters.\n\t \n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Initialization\n\t  #tempPosTextBefore := 0;\n\t  #tempPosTextAfter := 0;\n\t  #tempPosInArray := 0;\n\t  #tempLenTextBefore := LEN(#textBefore);\n\t  #tempLenTextAfter := LEN(#textAfter);\n\t  #extractedString := '';\n\t  #status := #STATUS_NO_ERROR;\n\t  #ExtractStringFromCharArray := #WARNING_NOTHING_FOUND;\n\t  \n\t  REGION Validation of inputs\n\t    // check whether the input is an ARRAY and TYPE of elements is CHAR or BYTE\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF TRUE\n\t      AND IS_ARRAY(#searchIn)\n\t      AND ((TypeOfElements(#searchIn) = Char) OR (TypeOfElements(#searchIn) = Byte))\n\t    THEN\n\t      // Get number of elements\n\t      #tempNumElements := CountOfElements(#searchIn);\n\t    ELSE\n\t      #status := #ERR_NO_ARRAY;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION Validation of inputs\n\tEND_REGION Initialization\n\t\n\tREGION Process\n\t  REPEAT // Search for text before until something was found\n\t    // Convert Chars to String\n\t    Chars_TO_Strg(Chars  := #searchIn,\n\t                  pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                  Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                  Strg   => #tempString);\n\t    \n\t    // Search for text before\n\t    #tempPosTextBefore := FIND(IN1 := #tempString, IN2 := #textBefore);\n\t    \n\t    // Text before was found\n\t    IF #tempPosTextBefore > 0 THEN\n\t      // Set position in array to end of text before\n\t      #tempPosInArray += #tempPosTextBefore + #tempLenTextBefore - 1;\n\t      \n\t      // Create new string from end of text before\n\t      Chars_TO_Strg(Chars  := #searchIn,\n\t                    pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                    Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                    Strg   => #tempString);\n\t      \n\t      // Find end of string to be extracted\n\t      #tempPosTextAfter := FIND(IN1 := #tempString, IN2 := #textAfter);\n\t      \n\t      IF #tempPosTextAfter > 0 THEN // Shorten string if text after was found\n\t        #extractedString := LEFT(IN := #tempString, L := #tempPosTextAfter - 1);\n\t        #ExtractStringFromCharArray := #STATUS_TEXT_FOUND;\n\t        EXIT;\n\t        \n\t      ELSE // Output whole string if text after was not found\n\t        #extractedString := #tempString;\n\t        #ExtractStringFromCharArray := #WARNING_ONLY_START;\n\t        EXIT;\n\t      END_IF;\n\t      \n\t    ELSE\n\t      // Otherwise continue search in next string minus length of text before to ensure\n\t      // keywords are not broken up at the end of a string and thus missed\n\t      #tempPosInArray += UINT_TO_INT(#LEN_STRING) - #tempLenTextBefore;\n\t    END_IF;\n\t    \n\t    // Repeat until end of array is reached\n\t  UNTIL (#tempPosInArray > #tempNumElements) END_REPEAT;\n\tEND_REGION Process\n\t\nEND_FUNCTION\n\n"
# example 4
requirement: {"title": "自动化灌装生产线控制", "description": "一个自动化灌装生产线负责对瓶子进行清洗、灌装、封盖和包装。生产线的每个步骤都由PLC控制，并且由传感器和操作员的输入信号触发。\n控制要求：\n当传感器bottleSensor检测到瓶子时，触发清洗泵启动并持续工作。\n清洗完成后，由操作员操作按钮cleaningConfirmButton触发清洗完成信号，自动启动灌装阀进行灌装。\n灌装完成后，由操作员操作按钮fillingConfirmButton触发灌装完成信号，自动启动封盖机进行封盖。\n封盖完成后，由操作员操作按钮cappingConfirmButton触发封盖完成信号，启动包装机进行包装。\n包装完成后，由操作员操作按钮packingConfirmButton触发包装完成信号，点亮包装完成指示灯。\n操作员取走包装好的瓶子后，按下确认按钮finishedButton复位指示灯，并为下一个瓶子的生产循环做准备。", "type": "FUNCTION_BLOCK", "name": "FB_BottleProcessing", "input": [{"name": "bottleSensor", "type": "Bool", "description": "瓶子到达传感器，检测到瓶子时触发信号"}, {"name": "cleaningConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认清洗工序完成"}, {"name": "fillingConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认灌装工序完成"}, {"name": "cappingConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认封盖工序完成"}, {"name": "packingConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认包装工序完成"}, {"name": "finishedButton", "type": "Bool", "description": "操作员确认按钮，用于确认瓶子已取走"}], "output": [{"name": "Pump_Motor", "type": "Bool", "description": "控制清洗泵电机的运行输出"}, {"name": "Filling_Valve", "type": "Bool", "description": "控制灌装阀的运行输出"}, {"name": "Capping_Machine", "type": "Bool", "description": "控制封盖机的运行输出"}, {"name": "Packing_Machine", "type": "Bool", "description": "控制包装机的运行输出"}, {"name": "Completion_Light", "type": "Bool", "description": "包装完成指示灯"}]}
SCL CODE: "FUNCTION_BLOCK \"FB_BottleProcessing\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      bottleSensor : BOOL;\n      cleaningConfirmButton : BOOL;\n      fillingConfirmButton : BOOL;\n      cappingConfirmButton : BOOL;\n      packingConfirmButton : BOOL;\n      finishedButton : BOOL;\n   END_VAR\n\n   VAR_OUTPUT \n      Pump_Motor : BOOL;\n      Filling_Valve : BOOL;\n      Capping_Machine : BOOL;\n      Packing_Machine : BOOL;\n      Completion_Light : BOOL;\n   END_VAR\n\n   VAR \n      State : INT := 0; (* 0: 等待瓶子, 1: 清洗, 2: 灌装, 3: 封盖, 4: 包装, 5: 完成 *)\n   END_VAR\n\n\nBEGIN\n   CASE State OF\n      0: (* 等待瓶子 *)\n         IF #bottleSensor THEN\n            #Pump_Motor := TRUE;\n            #State := 1;\n         END_IF;\n      1: (* 清洗 *)\n         IF #cleaningConfirmButton THEN\n            #Pump_Motor := FALSE;\n            #Filling_Valve := TRUE;\n            State := 2;\n         END_IF;\n      2: (* 灌装 *)\n         IF #fillingConfirmButton THEN\n            #Filling_Valve := FALSE;\n            #Capping_Machine := TRUE;\n            #State := 3;\n         END_IF;\n      3: (* 封盖 *)\n         IF #cappingConfirmButton THEN\n            #Capping_Machine := FALSE;\n            #Packing_Machine := TRUE;\n            #State := 4;\n         END_IF;\n      4: (* 包装 *)\n         IF #packingConfirmButton THEN\n            #Packing_Machine := FALSE;\n            #Completion_Light := TRUE;\n            #State := 5;\n         END_IF;\n      5: (* 完成 *)\n         IF #finishedButton THEN\n            #Completion_Light := FALSE;\n            (* 重置所有输入输出变量为默认值 *)\n            #Pump_Motor := FALSE;\n            #Filling_Valve := FALSE;\n            #Capping_Machine := FALSE;\n            #Packing_Machine := FALSE;\n            (* 返回等待瓶子状态 *)\n            #State := 0;\n         END_IF;\n   END_CASE;\nEND_FUNCTION_BLOCK\n"
# example 5
requirement: {"title": "计算一年中的第几天", "description": "在某些自动化系统中，可能需要根据当前日期计算出它是一年中的第几天。这可以用于追踪生产周期、维护计划或其他需要日期信息的场合。\n控制要求：\n系统需要接收日期输入，包括年、月、日。\n根据输入的日期，计算并输出它是一年中的第几天。\n考虑到不同年份的2月天数可能不同（平年28天，闰年29天），系统需要能够识别闰年并相应地计算。\n输出结果应该是一个整数，表示一年中的第几天。\n如果输入的日期不合法（如2月30日、4月31日等），系统应输出错误状态和错误代码。\n说明：\n1. 要求输入的年份Year在1000到3000之间（包括1000和3000），否则输出错误状态error=true和错误代码status=16#8001。如果输入的月份Month不合法，则输出错误状态error=true和错误代码status=16#8002。如果输入的日Day不合法，则输出错误状态error=true和错误代码status=16#8003。\n2. 计算的结果通过DayOfYear输出。", "type": "FUNCTION_BLOCK", "name": "FB_CalculateDayOfYear", "input": [{"name": "Year", "type": "Int", "description": "年份输入"}, {"name": "Month", "type": "Int", "description": "月份输入"}, {"name": "Day", "type": "Int", "description": "日输入"}], "output": [{"name": "DayOfYear", "type": "Int", "description": "一年中的第几天输出"}, {"name": "error", "type": "Bool", "description": "错误状态指示\nFALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}]}
SCL CODE: "FUNCTION_BLOCK \"FB_CalculateDayOfYear\"\n{ S7_Optimized_Access := 'TRUE' }\n   VAR_INPUT \n      Year : INT; \n      Month : INT; \n      Day : INT; \n   END_VAR\n\n   VAR_OUTPUT \n      DayOfYear : INT; \n      error : BOOL; \n      status : WORD; \n   END_VAR\n\n   VAR \n      DaysInMonth : ARRAY[1..12] OF INT := [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n      i: INT;\n   END_VAR\n\nBEGIN\n   // Initialize outputs\n   #DayOfYear := 0;\n   #error := FALSE;\n   #status := 0;\n   \n   // Check for valid year\n   IF (#Year < 1000) OR (#Year > 3000) THEN\n      #error := TRUE;\n      #status := 16#8001;\n      RETURN;\n   END_IF;\n   \n   // Check for valid month\n   IF (#Month < 1) OR (#Month > 12) THEN\n      #error := TRUE;\n      #status := 16#8002;\n      RETURN;\n   END_IF;\n   \n   // Adjust February days for leap year\n   IF (#Year MOD 4 = 0) AND (NOT (#Year MOD 100 = 0)) OR (#Year MOD 400 = 0) THEN\n      #DaysInMonth[2] := 29;\n   ELSE\n      #DaysInMonth[2] := 28;\n   END_IF;\n   \n   // Check for valid day\n   IF (#Day < 1) OR (#Day > #DaysInMonth[Month]) THEN\n      #error := TRUE;\n      #status := 16#8003;\n      RETURN;\n   END_IF;\n   \n   // Calculate DayOfYear\n   FOR #i := 1 TO #Month-1 DO\n      #DayOfYear := #DayOfYear + #DaysInMonth[i];\n   END_FOR;\n   #DayOfYear := #DayOfYear + #Day;\n   \nEND_FUNCTION_BLOCK\n"
# example 6
requirement: {"title": "控制台指示灯顺序控制", "description": "某控制台装有3个指示灯，分别为绿色、红色和黄色。需要通过一个控制按钮来循环控制这些灯的状态。\n控制要求：\n使用一个输入参数controlButton表示控制按钮的状态，该按钮为脉冲信号，每次触发时产生一个从0到1的跳变。\n使用三个输出参数greenLight、redLight、yellowLight分别来控制对应的绿色、红色和黄色指示灯。\n控制按钮触发的顺序和对应指示灯的状态如下：\n第1次触发：只有绿灯greenLight亮。\n第2次触发：只有红灯redLight亮。\n第3次触发：只有黄灯yellowLight亮。\n第4次触发：3个灯都亮。\n第5次触发：3个灯都灭。\n第6次触发及以后：重复上述循环。", "type": "FUNCTION_BLOCK", "name": "FB_ColorLightControl", "input": [{"name": "controlButton", "type": "Bool", "description": "控制按钮开关，脉冲信号"}], "output": [{"name": "greenLight", "type": "Bool", "description": "绿色指示灯"}, {"name": "redLight", "type": "Bool", "description": "红色指示灯"}, {"name": "yellowLight", "type": "Bool", "description": "黄色指示灯"}]}
SCL CODE: "FUNCTION_BLOCK \"FB_ColorLightControl\"\n{ S7_Optimized_Access := 'TRUE' }\n   VAR_INPUT \n      controlButton : BOOL; // Control button state, pulse signal\n   END_VAR\n\n   VAR_OUTPUT \n      greenLight : BOOL; // Green light control\n      redLight : BOOL; // Red light control\n      yellowLight : BOOL; // Yellow light control\n   END_VAR\n\n   VAR \n      state : INT := 1; // State variable to track the light sequence\n      lastControlButton : BOOL := FALSE; // Variable to store the last state of the control button\n   END_VAR\n\n\nBEGIN\n   // Check for rising edge of controlButton\n   IF #controlButton AND NOT #lastControlButton THEN\n      CASE #state OF\n         1:\n            #greenLight := TRUE;\n            #redLight := FALSE;\n            #yellowLight := FALSE;\n            #state := 2;\n         2:\n            #greenLight := FALSE;\n            #redLight := TRUE;\n            #yellowLight := FALSE;\n            #state := 3;\n         3:\n            #greenLight := FALSE;\n            #redLight := FALSE;\n            #yellowLight := TRUE;\n            #state := 4;\n         4:\n            #greenLight := TRUE;\n            #redLight := TRUE;\n            #yellowLight := TRUE;\n            #state := 5;\n         5:\n            #greenLight := FALSE;\n            #redLight := FALSE;\n            #yellowLight := FALSE;\n            #state := 1; // Reset to state 1 to start the cycle over\n      END_CASE;\n   END_IF;\n   \n   // Update the last state of the control button\n   #lastControlButton := #controlButton;\nEND_FUNCTION_BLOCK"
# example 7
requirement: {"title": "PLC数据库数据存储与管理系统", "description": "在一些自动化应用中，PLC需要收集和存储大量的数据，例如传感器读数、生产计数或其他过程变量。这些数据通常存储在PLC的内部数据库或外部数据库系统中。\n控制要求：\n系统需要接收一组数据dataInput，以字节数组构建，这组数据的第一个字节dataInput[0]表示要存入的数据字节长度。\n数据的存储操作由输入storeTrigger触发。\n数据需要依次存入数据库，每组数据长度可能不同。\n当数据库剩余空间不足以存入新的一组数据时，系统应触发报错error。\n系统应提供一个复位功能，通过输入resetTrigger来清空数据库，并重置error。\n系统应能够输出数据库的当前使用情况和剩余空间。\n说明：\n1. 当存储信号storeTrigger触发时，首先检查数据输入长度信息（即数组的首字节dataInput[0]）是否非法，如果小于等于0或大于5，则输出错误状态error=true和错误代码status=16#8001。如果数据库剩余空间不足以存入新数据，则输出错误状态error=true和错误代码status=16#8002。如果没有这些错误，则根据长度信息，把从输入数组的第二字节开始的数据取出，并存入数据库。存入时不能覆盖数据库原有的数据，从原有数据之后依次存入。\n2. 当复位信号resetTrigger触发时，清空数据库中所有数据，并复位错误状态error=0和status=0。\n3. 数据库已使用空间和剩余空间分别通过usedSpace和remainingSpace输出。", "type": "FUNCTION_BLOCK", "name": "FB_DatabaseManager", "input": [{"name": "dataInput", "type": "Array[0..5] of Byte", "description": "数据输入，字节数组"}, {"name": "storeTrigger", "type": "Bool", "description": "存储触发信号"}, {"name": "resetTrigger", "type": "Bool", "description": "复位触发信号"}], "output": [{"name": "usedSpace", "type": "Int", "description": "数据库已使用空间"}, {"name": "remainingSpace", "type": "Int", "description": "数据库剩余空间"}, {"name": "error", "type": "Bool", "description": "错误状态指示\nFALSE:没有发生错误\nTRUE:执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "dataBase", "type": "Array[1..20] of Byte", "description": "数据库，字节数组"}]}
SCL CODE: "FUNCTION_BLOCK \"FB_DatabaseManager\"\n{ S7_Optimized_Access := 'TRUE' }\n   VAR_INPUT \n      dataInput : Array[0..5] of Byte;\n      storeTrigger : Bool;\n      resetTrigger : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      usedSpace : Int := 0;\n      remainingSpace : Int :=20;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      dataBase : Array[1..20] of Byte;\n   END_VAR\n\n   VAR\n      index : Int;\n      dataLength : Int;\n      i : INT;\n   END_VAR\n\n\nBEGIN\n   // Initialization\n   IF #resetTrigger THEN\n      FOR #i := 1 TO 20 DO\n         #dataBase[i] := 0;\n      END_FOR;\n      #usedSpace := 0;\n      #remainingSpace := 20;\n      #error := FALSE;\n      #status := 0;\n   END_IF;\n   \n   // Data storage operation\n   IF #storeTrigger THEN\n      #dataLength := #dataInput[0];\n      // Check data length validity\n      IF #dataLength <= 0 OR #dataLength > 5 THEN\n         #error := TRUE;\n         #status := 16#8001;\n      ELSIF #usedSpace + #dataLength > 20 THEN\n         // Check if there is enough space in the database\n         #error := TRUE;\n         #status := 16#8002;\n      ELSE\n         // Store data\n         FOR #index := 1 TO #dataLength DO\n            #dataBase[#usedSpace + #index] := #dataInput[#index];\n         END_FOR;\n         #usedSpace := #usedSpace + #dataLength;\n         #remainingSpace := 20 - #usedSpace;\n         #error := FALSE;\n         #status := 0;\n      END_IF;\n   END_IF;\n   \n   // Output the current usage and remaining space of the database\nEND_FUNCTION_BLOCK\n"
# example 8
requirement: {"title": "浮点数区间线性化转换", "description": "在一些自动化控制系统中，可能需要将一个物理量（如温度、压力等）的测量值转换为另一个线性化或标准化的值，以便于控制算法的处理或显示。例如，一个传感器测量的物理量可能在特定的非线性区间内变化，但控制系统需要一个线性化的值来进行计算。\n控制要求：\n系统需要接收一个浮点数作为输入，表示原始测量值。\n根据输入值的大小，将其转换到不同的线性区间，输出转换后的线性化值。\n当输入值在1200到3600之间，则转换到150到240之间。\n当输入值在3600到4800之间，则转换到240到560之间。\n当输入值在4800到7000之间，则转换到560到720之间。\n如果输入值小于1200或大于7000，则转换后的值应为1200或7000对应的线性化值，并输出错误状态error=1，status=16#8001。", "type": "FUNCTION_BLOCK", "name": "FB_LinearizeValue", "input": [{"name": "InputValue", "type": "Real", "description": "浮点数输入，原始测量值"}], "output": [{"name": "LinearizedValue", "type": "Real", "description": "转换后的线性化值"}, {"name": "Error", "type": "Bool", "description": "错误状态指示\nFALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "Status", "type": "Word", "description": "状态代码"}]}
SCL CODE: "FUNCTION_BLOCK \"FB_LinearizeValue\"\n{ S7_Optimized_Access := 'TRUE' }\n   VAR_INPUT \n      InputValue : REAL; // 浮点数输入，原始测量值\n   END_VAR\n\n   VAR_OUTPUT \n      LinearizedValue : REAL; // 转换后的线性化值\n      Error : BOOL; // 错误状态指示\n      Status : WORD; // 状态代码\n   END_VAR\n\n   VAR \n      // 不需要在此处声明额外的变量\n   END_VAR\n\n\nBEGIN\n   // 初始化输出值\n   #LinearizedValue := 0.0;\n   #Error := FALSE;\n   #Status := 16#0000;\n   \n   // 判断输入值InputValue是否在指定区间内，并进行转换\n   IF #InputValue < 1200 THEN\n      // 输入值小于1200\n      #LinearizedValue := 150.0;\n      #Error := TRUE;\n      #Status := 16#8001;\n   ELSIF #InputValue <= 3600 THEN\n      // 输入值在1200到3600之间，转换到150到240之间\n      #LinearizedValue := 150.0 + (#InputValue - 1200) * (240 - 150) / (3600 - 1200);\n   ELSIF #InputValue <= 4800 THEN\n      // 输入值在3600到4800之间，转换到240到560之间\n      #LinearizedValue := 240.0 + (#InputValue - 3600) * (560 - 240) / (4800 - 3600);\n   ELSIF #InputValue <= 7000 THEN\n      // 输入值在4800到7000之间，转换到560到720之间\n      #LinearizedValue := 560.0 + (#InputValue - 4800) * (720 - 560) / (7000 - 4800);\n   ELSE\n      // 输入值大于7000\n      #LinearizedValue := 720.0;\n      #Error := TRUE;\n      #Status := 16#8001;\n   END_IF;\n   \nEND_FUNCTION_BLOCK\n"
# example 9
requirement: {"title": "自动化生产线控制", "description": "一个简单的自动化生产线由三个工作站组成：工作站A、工作站B和工作站C。产品需要经过这三个站的依次加工后才算全部完成。生产线有一个电机，负责将产品从一个工作站移动到下一个工作站，生成线的顺序是从工作站A到工作站B，再到工作站C。每个工作站都有一个传感器（用于检测产品是否到达）以及一个按钮（用于触发本站加工完成信号）。\n控制要求：\n1. 模式切换：转换开关（Mode）用于切换生产线的手动和自动模式。\n2. 手动模式：在手动模式下，电机正转按钮（ForwardButton）控制电机正转，电机反转按钮（ReverseButton）控制电机反转，正反转操作需要互锁，不能同时进行。\n3. 自动模式：\n   - 产品到达工作站A，SensorA检测到产品，操作员通过ButtonA触发加工完成信号后，电机启动正转，将产品移动到工作站B。\n   - 产品到达工作站B，SensorB检测到产品，电机停止，操作员通过ButtonB触发加工完成信号后，电机启动正转，将产品移动到工作站C。\n   - 产品到达工作站C，SensorC检测到产品，电机停止，操作员通过ButtonC触发加工完成信号后，加工完成指示灯（CompletionLight）亮起，指示产品加工完成。当产品被取走，也就是SensorC检测不到产品了，加工完成指示灯（CompletionLight）熄灭。", "type": "FUNCTION_BLOCK", "name": "FB_ProductionLineControl", "input": [{"name": "Mode", "type": "Bool", "description": "用于切换生产线的手动和自动模式，0=手动模式，1=自动模式"}, {"name": "ForwardButton", "type": "Bool", "description": "正转按钮"}, {"name": "ReverseButton", "type": "Bool", "description": "反转按钮"}, {"name": "SensorA", "type": "Bool", "description": "传感器A"}, {"name": "SensorB", "type": "Bool", "description": "传感器B"}, {"name": "SensorC", "type": "Bool", "description": "传感器C"}, {"name": "ButtonA", "type": "Bool", "description": "按钮A"}, {"name": "ButtonB", "type": "Bool", "description": "按钮B"}, {"name": "ButtonC", "type": "Bool", "description": "按钮C"}], "output": [{"name": "MotorForward", "type": "Bool", "description": "电机正转输出"}, {"name": "MotorReverse", "type": "Bool", "description": "电机反转输出"}, {"name": "CompletionLight", "type": "Bool", "description": "产品加工完成指示灯"}]}
SCL CODE: "FUNCTION_BLOCK \"FB_ProductionLineControl\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      Mode : BOOL; // 用于切换生产线的手动和自动模式\n      ForwardButton : BOOL; // 正转按钮\n      ReverseButton : BOOL; // 反转按钮\n      SensorA : BOOL; // 传感器A\n      SensorB : BOOL; // 传感器B\n      SensorC : BOOL; // 传感器C\n      ButtonA : BOOL; // 按钮A\n      ButtonB : BOOL; // 按钮B\n      ButtonC : BOOL; // 按钮C\n   END_VAR\n\n   VAR_OUTPUT \n      MotorForward : BOOL; // 电机正转输出\n      MotorReverse : BOOL; // 电机反转输出\n      CompletionLight : BOOL; // 产品加工完成指示灯\n   END_VAR\n\n   VAR \n      State : INT; // 状态机当前状态\n   END_VAR\n\n\nBEGIN\n   // 状态机初始化\n   IF #State = 0 THEN\n      #MotorForward := FALSE;\n      #MotorReverse := FALSE;\n      #CompletionLight := FALSE;\n      #State := 1; // 初始状态\n   END_IF;\n   \n   // 手动模式\n   IF #Mode = FALSE THEN\n      IF #ForwardButton AND NOT #ReverseButton THEN\n         #MotorForward := TRUE;\n         #MotorReverse := FALSE;\n      ELSIF #ReverseButton AND NOT #ForwardButton THEN\n         #MotorReverse := TRUE;\n         #MotorForward := FALSE;\n      ELSE\n         #MotorForward := FALSE;\n         #MotorReverse := FALSE;\n      END_IF;\n   ELSE // 自动模式\n      CASE #State OF\n         1: // 等待产品到达A\n            IF #SensorA THEN\n               #State := 2;\n            END_IF;\n         2: // 等待按钮A按下\n            IF #ButtonA THEN\n               #MotorForward := TRUE;\n               #State := 3;\n            END_IF;\n         3: // 等待产品到达B\n            IF #SensorB THEN\n               #MotorForward := FALSE;\n               #State := 4;\n            END_IF;\n         4: // 等待按钮B按下\n            IF #ButtonB THEN\n               #MotorForward := TRUE;\n               #State := 5;\n            END_IF;\n         5: // 等待产品到达C\n            IF #SensorC THEN\n               #MotorForward := FALSE;\n               #State := 6;\n            END_IF;\n         6: // 等待按钮C按下\n            IF #ButtonC THEN\n               #CompletionLight := TRUE;\n               #State := 7;\n            END_IF;\n         7: // 等待产品被取走\n            IF NOT #SensorC THEN\n               #CompletionLight := FALSE;\n               #State := 1;\n            END_IF;\n      END_CASE;\n   END_IF; \nEND_FUNCTION_BLOCK\n"
# example 10
requirement: {"title": "配方管理系统", "description": "某工厂的生产线需要根据不同的配方生产多种产品。生产线的控制中心需要一个配方管理系统，允许操作员添加、删除、修改和查询配方数据。\n控制要求：\n配方数据应包括配方编号、原料类型、原料比例和生产温度。\n系统应允许输入新的配方数据，并将其存储在配方数据库中。\n系统应允许通过配方编号删除或修改现有的配方数据。\n系统应允许通过配方编号查询配方详情，并输出该配方。\n说明：\n1. 配方以结构体Struct数据类型构建，结构体内包括配方编号recipeID、原料类型ingredientType、原料比例ingredientRatio和生产温度productionTemperature。配方数据库最多可以存放10条配方，以数组Array[1..10] of Struct构建，配方编号不能重复，配方编号=0表示该位置空闲。\n2. 当触发查询配方请求信号queryRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果不存在该编号，则输出错误状态error=true和错误代码status=16#8001。如果存在该编号，则把该条配方输出到配方查询结果recipeQueryResult。\n3. 当触发添加配方请求信号addRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果存在重号，则输出错误状态error=true和错误代码status=16#8002。如果配方数据库recipe中没有空余位置，则输出错误状态error=true和错误代码status=16#8003。如果不存在这些错误，则把输入配方recipeIn存入配方数据库recipe，优先存入数组编号小的空闲位置。\n4. 当触发删除配方请求信号deleteRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果不存在该编号，则输出错误状态error=true和错误代码status=16#8004。如果存在该编号，则删除该配方，即把配方数据库recipe中的该条配方编号recipeID置为0。\n5. 当触发修改配方请求信号modifyRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果不存在该编号，则输出错误状态error=true和错误代码status=16#8005。如果存在该编号，则把该条配方替换为输入配方recipeIn。", "type": "FUNCTION_BLOCK", "name": "FB_RecipeManager", "input": [{"name": "addRecipe", "type": "Bool", "description": "添加配方请求信号"}, {"name": "deleteRecipe", "type": "Bool", "description": "删除配方请求信号"}, {"name": "modifyRecipe", "type": "Bool", "description": "修改配方请求信号"}, {"name": "queryRecipe", "type": "Bool", "description": "查询配方请求信号"}, {"name": "recipeIn", "type": "Struct", "description": "输入配方", "fields": [{"name": "recipeID", "type": "Int", "description": "配方编号"}, {"name": "ingredientType", "type": "Int", "description": "原料类型"}, {"name": "ingredientRatio", "type": "Real", "description": "原料比例"}, {"name": "productionTemperature", "type": "Real", "description": "生产温度"}]}], "output": [{"name": "recipeAdded", "type": "Bool", "description": "配方添加成功指示"}, {"name": "recipeDeleted", "type": "Bool", "description": "配方删除成功指示"}, {"name": "recipeModified", "type": "Bool", "description": "配方修改成功指示"}, {"name": "recipeQueryResult", "type": "Struct", "description": "配方查询结果输出", "fields": [{"name": "recipeID", "type": "Int", "description": "配方编号"}, {"name": "ingredientType", "type": "Int", "description": "原料类型"}, {"name": "ingredientRatio", "type": "Real", "description": "原料比例"}, {"name": "productionTemperature", "type": "Real", "description": "生产温度"}]}, {"name": "error", "type": "Bool", "description": "错误状态指示\nFALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "recipe", "type": "Array[1..10] of Struct", "description": "配方数据库", "fields": [{"name": "recipeID", "type": "Int", "description": "配方编号"}, {"name": "ingredientType", "type": "Int", "description": "原料类型"}, {"name": "ingredientRatio", "type": "Real", "description": "原料比例"}, {"name": "productionTemperature", "type": "Real", "description": "生产温度"}]}]}
SCL CODE: "FUNCTION_BLOCK \"FB_RecipeManager\"\n{ S7_Optimized_Access := 'TRUE' }\n   VAR_INPUT \n      addRecipe : BOOL;\n      deleteRecipe : BOOL;\n      modifyRecipe : BOOL;\n      queryRecipe : BOOL;\n      recipeIn : STRUCT \n         recipeID : INT;\n         ingredientType : INT;\n         ingredientRatio : REAL;\n         productionTemperature : REAL;\n      END_STRUCT;\n   END_VAR\n\n   VAR_OUTPUT \n      recipeAdded : BOOL;\n      recipeDeleted : BOOL;\n      recipeModified : BOOL;\n      recipeQueryResult : STRUCT \n         recipeID : INT;\n         ingredientType : INT;\n         ingredientRatio : REAL;\n         productionTemperature : REAL;\n      END_STRUCT;\n      error : BOOL;\n      status : WORD;\n   END_VAR\n\n   VAR_IN_OUT \n      recipe : ARRAY[1..10] OF STRUCT \n         recipeID : INT;\n         ingredientType : INT;\n         ingredientRatio : REAL;\n         productionTemperature : REAL;\n      END_STRUCT;\n   END_VAR\n\n   VAR\n      i : INT;\n      found : BOOL;\n   END_VAR\n\n\nBEGIN\n   // Reset output flags\n   #recipeAdded := FALSE;\n   #recipeDeleted := FALSE;\n   #recipeModified := FALSE;\n   #error := FALSE;\n   #status := 0;\n   \n   // Add recipe logic\n   IF #addRecipe THEN\n      #found := FALSE;\n      FOR #i := 1 TO 10 DO\n         IF #recipe[i].recipeID = #recipeIn.recipeID THEN\n            #found := TRUE;\n            #error := TRUE;\n            #status := 16#8002;\n            RETURN;\n         END_IF;\n      END_FOR;\n      \n      IF NOT #found THEN\n         #found := FALSE;\n         FOR #i := 1 TO 10 DO\n            IF #recipe[i].recipeID = 0 THEN\n               #recipe[i] := #recipeIn;\n               #recipeAdded := TRUE;\n               #found := TRUE;\n               EXIT;\n            END_IF;\n         END_FOR;\n         \n         IF NOT #found THEN\n            #error := TRUE;\n            #status := 16#8003;\n         END_IF;\n      END_IF;\n   END_IF;\n   \n   // Delete recipe logic\n   IF #deleteRecipe THEN\n      #found := FALSE;\n      FOR #i := 1 TO 10 DO\n         IF #recipe[i].recipeID = #recipeIn.recipeID THEN\n            #recipe[i].recipeID := 0;\n            #recipeDeleted := TRUE;\n            #found := TRUE;\n            EXIT;\n         END_IF;\n      END_FOR;\n      \n      IF NOT #found THEN\n         #error := TRUE;\n         #status := 16#8004;\n      END_IF;\n   END_IF;\n   \n   // Modify recipe logic\n   IF #modifyRecipe THEN\n      #found := FALSE;\n      FOR #i := 1 TO 10 DO\n         IF #recipe[i].recipeID = #recipeIn.recipeID THEN\n            #recipe[i] := #recipeIn;\n            #recipeModified := TRUE;\n            #found := TRUE;\n            RETURN;\n         END_IF;\n      END_FOR;\n      \n      IF NOT #found THEN\n         #error := TRUE;\n         #status := 16#8005;\n      END_IF;\n   END_IF;\n   \n   // Query recipe logic\n   IF #queryRecipe THEN\n      #found := FALSE;\n      FOR #i := 1 TO 10 DO\n         IF #recipe[i].recipeID = #recipeIn.recipeID THEN\n            #recipeQueryResult := #recipe[i];\n            #found := TRUE;\n            RETURN;\n         END_IF;\n      END_FOR;\n      \n      IF NOT #found THEN\n         #error := TRUE;\n         #status := 16#8001;\n      END_IF;\n   END_IF;\n   \nEND_FUNCTION_BLOCK\n"
# example 11
requirement: {"title": "数字位分离显示", "description": "在一些自动化系统中，可能需要将一个整数的各个位分离出来，以便于显示或进一步处理。例如，在一些计数器或生产计数应用中，需要将当前的计数值分离成个位、十位、百位和千位。\n控制要求：\n系统需要接收一个最多四位整数作为输入。\n根据输入的整数，计算并输出其个位、十位、百位和千位数值。\n如果输入的整数少于四位，则在缺失的高位上显示0。\n输出结果应该是四个独立的整数，分别代表个位、十位、百位和千位。\n说明：\n1. 要求输入的整数InputNumber大于等于0且小于10000，否则输出错误状态error=true和错误代码status=16#8001。\n2. 在计算出个、十、百、千这四个数位的数值后，对这四个数位值中非0的值进行比较并输出最小值到Min；如果InputNumber=0，则输出Min=0。", "type": "FUNCTION_BLOCK", "name": "FB_SplitNumber", "input": [{"name": "InputNumber", "type": "Int", "description": "四位整数输入"}], "output": [{"name": "Thousands", "type": "Byte", "description": "千位数值输出"}, {"name": "Hundreds", "type": "Byte", "description": "百位数值输出"}, {"name": "Tens", "type": "Byte", "description": "十位数值输出"}, {"name": "Ones", "type": "Byte", "description": "个位数值输出"}, {"name": "Min", "type": "Byte", "description": "四个数位中的非0最小值"}, {"name": "error", "type": "Bool", "description": "错误状态指示\nFALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}]}
SCL CODE: "FUNCTION_BLOCK \"FB_SplitNumber\"\n{ S7_Optimized_Access := 'TRUE' }\n   VAR_INPUT \n      InputNumber : INT; \n   END_VAR\n\n   VAR_OUTPUT \n      Thousands : BYTE; \n      Hundreds : BYTE; \n      Tens : BYTE; \n      Ones : BYTE; \n      Min : BYTE; \n      error : BOOL; \n      status : WORD; \n   END_VAR\n\n   VAR \n      tempNumber : INT; \n      minValue : BYTE; \n   END_VAR\n\n\nBEGIN\n   // Check if the input number is within the valid range\n   IF (#InputNumber < 0) OR (#InputNumber >= 10000) THEN\n      #error := TRUE;\n      #status := 16#8001;\n      // Set the outputs to default values\n      #Thousands := 0;\n      #Hundreds := 0;\n      #Tens := 0;\n      #Ones := 0;\n      #Min := 0;\n   ELSE\n      // The input number is valid\n      #error := FALSE;\n      #status := 0;\n      \n      // Split the number into thousands, hundreds, tens and ones\n      #tempNumber := #InputNumber;\n      #Thousands := INT_TO_BYTE(#tempNumber / 1000);\n      #tempNumber := #tempNumber MOD 1000;\n      #Hundreds := INT_TO_BYTE(#tempNumber / 100);\n      #tempNumber := #tempNumber MOD 100;\n      #Tens := INT_TO_BYTE(#tempNumber / 10);\n      #Ones := INT_TO_BYTE(#tempNumber MOD 10);\n      \n      // Find the minimum non-zero value\n      #minValue := 255; // Initialize with the maximum value for a BYTE\n      IF #Thousands > 0 THEN #minValue := MIN(IN1:=#minValue, IN2:=#Thousands); END_IF;\n      IF #Hundreds > 0 THEN #minValue := MIN(IN1:=#minValue, IN2:=#Hundreds); END_IF;\n      IF #Tens > 0 THEN #minValue := MIN(IN1:=#minValue, IN2:=#Tens); END_IF;\n      IF #Ones > 0 THEN #minValue := MIN(IN1:=#minValue, IN2:=#Ones); END_IF;\n      \n      // If all digits are zero, set Min to zero\n      IF #minValue = 255 THEN #minValue := 0; END_IF;\n      \n      #Min := #minValue;\n   END_IF;\nEND_FUNCTION_BLOCK\n"
# example 12
requirement: {"title": "16位二进制数分解为四个4位二进制数", "description": "在一些数据处理和通信应用中，需要将一个16位的二进制数分解成四个独立的4位二进制数。例如，在数据编码、解码或与外部系统的数据交换时，可能需要这种分解操作。\n控制要求：\n系统需要接收一个16位的二进制数InputWord作为输入。\n将输入的16位二进制数分解成四个4位的二进制数，分别对应输入数的最低位到最高位。\n输出这四个4位二进制数到独立的变量Byte0~Byte3中。\n同时对这4个变量Byte0~Byte3中非0的变量求取平均值，并输出到average。\n例如，InputWord=16#1203，则Byte0=3，Byte1=0，Byte2=2，Byte3=1，那么平均值average=(1+2+3)/3", "type": "FUNCTION_BLOCK", "name": "FB_SplitWordIntoBytes", "input": [{"name": "InputWord", "type": "Word", "description": "16位二进制数输入"}], "output": [{"name": "Byte0", "type": "Byte", "description": "最低的4位二进制数输出"}, {"name": "Byte1", "type": "Byte", "description": "次低的4位二进制数输出"}, {"name": "Byte2", "type": "Byte", "description": "次高的4位二进制数输出"}, {"name": "Byte3", "type": "Byte", "description": "最高的4位二进制数输出"}, {"name": "average", "type": "Real", "description": "四个字节中非零字节的平均值"}]}
SCL CODE: "FUNCTION_BLOCK \"FB_SplitWordIntoBytes\"\n{ S7_Optimized_Access := 'TRUE' }\n   VAR_INPUT \n      InputWord : Word;\n   END_VAR\n\n   VAR_OUTPUT \n      Byte0 : Byte;\n      Byte1 : Byte;\n      Byte2 : Byte;\n      Byte3 : Byte;\n      average : Real;\n   END_VAR\n\n   VAR \n      nonZeroCount : Int := 0;\n      sum : Real := 0.0;\n   END_VAR\n\n\nBEGIN\n   #nonZeroCount := 0;\n   #sum := 0;\n\n   // Split the InputWord into four bytes\n   #Byte0 := WORD_TO_BYTE(#InputWord AND 16#000F);\n   #Byte1 := WORD_TO_BYTE(SHR(IN := #InputWord, N := 4) AND 16#000F);\n   #Byte2 := WORD_TO_BYTE(SHR(IN := #InputWord, N := 8) AND 16#000F);\n   #Byte3 := WORD_TO_BYTE(SHR(IN := #InputWord, N := 12) AND 16#000F);\n   \n   // Calculate the average of non-zero bytes\n   IF #Byte0 <> 0 THEN\n      #nonZeroCount := #nonZeroCount + 1;\n      #sum := #sum + #Byte0;\n   END_IF;\n   IF #Byte1 <> 0 THEN\n      #nonZeroCount := #nonZeroCount + 1;\n      #sum := #sum + #Byte1;\n   END_IF;\n   IF #Byte2 <> 0 THEN\n      #nonZeroCount := #nonZeroCount + 1;\n      #sum := #sum + #Byte2;\n   END_IF;\n   IF #Byte3 <> 0 THEN\n      #nonZeroCount := #nonZeroCount + 1;\n      #sum := #sum + #Byte3;\n   END_IF;\n   \n   IF #nonZeroCount > 0 THEN\n      #average := #sum / #nonZeroCount;\n   ELSE\n      #average := 0.0;\n   END_IF;\nEND_FUNCTION_BLOCK\n"
# example 13
requirement: {"title": "自动化仓库货架位置管理系统", "description": "一个自动化仓库需要一个系统来管理工件的存放位置，确保工件能够高效地被存取。仓库里有一个货架，共有9层，每层编号从1到9，每层仅能存放一件工件。\n控制要求：\n1. 系统需要维护货架的存储状态，记录每层是否存放工件。\n2. 当工件入库时：\n   - 查询货架的存储状态。\n   - 如果有空闲位置，优先存放编号大的位置。\n   - 如果所有位置都被占用，则输出错误状态error=1和错误代码status16#8001。\n3. 当工件出库时：\n   - 查询货架的存储状态。\n   - 如果货架上有工件，优先取出位置编号小的工件。\n   - 如果所有位置都为空，则输出错误状态error=1和错误代码status16#8002。\n4. 系统应能输出当前工件库存数量和货架空闲位置数量。", "type": "FUNCTION_BLOCK", "name": "FB_WarehouseManagement", "input": [{"name": "requestIn", "type": "Bool", "description": "入库请求信号"}, {"name": "requestOut", "type": "Bool", "description": "出库请求信号"}], "output": [{"name": "productNum", "type": "Int", "description": "工件库存数量"}, {"name": "libFreeNum", "type": "Int", "description": "货架空闲位置数量"}, {"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "library", "type": "Array[1..9] of Bool", "description": "货架每层的占用状态，1表示占用，0表示空闲"}]}
SCL CODE: "FUNCTION_BLOCK \"FB_WarehouseManagement\"\n{ S7_Optimized_Access := 'TRUE' }\n   VAR_INPUT \n      requestIn : Bool := FALSE;\n      requestOut : Bool := FALSE;\n   END_VAR\n\n   VAR_OUTPUT \n      productNum : Int := 0;\n      libFreeNum : Int := 9;\n      error : Bool := FALSE;\n      status : Word := 16#0000;\n   END_VAR\n\n   VAR_IN_OUT \n      library : Array[1..9] of Bool := [FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];\n   END_VAR\n\n   VAR \n      i : INT;\n      errFull : Word := 16#8001;\n      errEmpty : Word := 16#8002;\n   END_VAR\n\nBEGIN\n     // 初始化error和status变量\n     #error := FALSE;\n     #status := 16#0000;\n\n     // 入库逻辑\n     IF #requestIn THEN\n        // 从编号大的位置开始查找空闲位置\n        FOR #i := 9 TO 1 BY -1 DO\n           IF NOT #library[i] THEN\n              // 找到空闲位置，更新状态\n              #library[i] := TRUE;\n              #productNum := productNum + 1;\n              #libFreeNum := libFreeNum - 1;\n              EXIT;\n           END_IF;\n        END_FOR;\n        \n        // 如果没有找到空闲位置，则报错\n        IF #i = 0 THEN\n           #error := TRUE;\n           #status := #errFull;\n        END_IF;\n     END_IF;\n\n     // 出库逻辑\n     IF #requestOut THEN\n        // 从编号小的位置开始查找工件\n        FOR #i := 1 TO 9 DO\n           IF #library[i] THEN\n              // 找到工件，更新状态\n              #library[i] := FALSE;\n              #productNum := #productNum - 1;\n              #libFreeNum := #libFreeNum + 1;\n              EXIT;\n           END_IF;\n        END_FOR;\n        \n        // 如果没有找到工件，则报错\n        IF #i > 9 THEN\n           #error := TRUE;\n           #status := #errEmpty;\n        END_IF;\n     END_IF;\nEND_FUNCTION_BLOCK"
# example 14
requirement: {"title": "FIFO先进先出队列", "description": "编写一个函数块FB，实现一个先进先出（FIFO）循环队列的功能，其中队列的最大长度和数据类型都是可变的。循环队列应能够支持以下操作：\n\n1. 入队操作（enqueue）：在队列未满的情况下，将一个元素添加到队列的队尾。\n2. 出队操作（dequeue）：在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。\n3. 判断队列是否为空：检查队列中是否没有元素。\n4. 判断队列是否已满：检查队列是否已达到最大容量。\n5. 获取队列元素数量：返回队列中当前元素的数量。\n状态代码：\n16#0000：执行FB没有出错\n16#8001：队列是空的\n16#8002：队列是满的", "type": "FUNCTION_BLOCK", "name": "FIFO", "input": [{"name": "enqueue", "type": "Bool", "description": "入队操作，在队列未满的情况下，将一个元素添加到队列的队尾"}, {"name": "dequeue", "type": "Bool", "description": "出队操作，在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。"}, {"name": "reset", "type": "Bool", "description": "复位操作，复位头尾指针，元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。"}, {"name": "clear", "type": "Bool", "description": "清除操作，复位头尾指针，队列将被清空并用初始值initialItem进行初始化。元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。"}, {"name": "initialItem", "type": "Variant", "description": "用于初始化队列的值"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE:没有发生错误 TRUE:执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}, {"name": "elementCount", "type": "DInt", "description": "队列中元素的数量"}, {"name": "isEmpty", "type": "Bool", "description": "当为TRUE时表示队列是空的"}], "in/out": [{"name": "item", "type": "Variant", "description": "用于加入队列或从队列返回的值"}, {"name": "buffer", "type": "Variant", "description": "用于作为队列的数组"}], "status_codes": {"16#0000": "执行FB没有出错", "16#8001": "队列是空的", "16#8002": "队列是满的"}}
SCL CODE: "FUNCTION_BLOCK \"FIFO\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      enqueue : Bool := FALSE;\n      dequeue : Bool := FALSE;\n      reset : Bool;\n      clear : Bool;\n      initialItem : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      elementCount : DInt := 0;\n      isEmpty : Bool := FALSE;\n   END_VAR\n\n   VAR_IN_OUT \n      item : Variant;\n      buffer : Variant;\n   END_VAR\n\n   VAR \n      statEdgesMem : Struct\n         enqueue : Bool;\n         dequeue : Bool;\n         clear : Bool;\n      END_STRUCT;\n      statFirstItemIndex : Int := -1;\n      statNextEmptyItemIndex : Int := 0;\n      statElementCount : DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempEdges : Struct\n         enqueue : Bool;\n         dequeue : Bool;\n         clear : Bool;\n      END_STRUCT;\n      tempInternalError : Int;\n      tempNewFirstItemIndex : Int;\n      tempNewNextEmptyItemIndex : Int;\n      tempBufferSize : UDInt;\n      tempCounter : Int;\n   END_VAR\n\n   VAR CONSTANT \n      BUFFER_IS_EMPTY : Int := -1;\n      NO_INTERNAL_ERROR : Int := 0;\n      BUFFER_INITIALIZED : Int := -1;\n      EMPTY_INITIALIZED : Int := 0;\n      INDEX_BEGINNING : Int := 0;\n      COUNT_ELEMENTS : UDInt := 1;\n      INCREMENT : Int := 1;\n      BUFFER_SIZE_CORRECTION : UDInt := 1;\n      COUNTER_LOWER_LIMIT : Int := 0;\n      ZERO_ELEMENTS : DInt := 0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      ERR_BUFFER_EMPTY : Word := 16#8001;\n      ERR_BUFFER_FULL : Word := 16#8002;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_WRONG_TYPE_ITEM : Word := 16#8201;\n      ERR_WRONG_TYPE_INITIAL_ITEM : Word := 16#8202;\n      ERR_INDEX_IN_ARRAY_LIMITS_1 : Word := 16#8601;\n      ERR_INDEX_IN_ARRAY_LIMITS_2 : Word := 16#8602;\n      ERR_CLEAR_BUFFER : Word := 16#8610;\n      ERR_RETURN_FIRST_ENTRY : Word := 16#8611;\n      ERR_REPLACE_ITEM_BY_INIT_VALUE : Word := 16#8612;\n      ERR_WRITE_ENTRY : Word := 16#8613;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //===============================================================================\n\t    // Title:           FIFO\n\t    // Comment/Function: FIFO (First In First Out)\n\t    //                   Queue / ring buffer memory\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Block execution control\n\t    // collect edges\n\t    #tempEdges.enqueue := #enqueue AND NOT #statEdgesMem.enqueue;\n\t    #tempEdges.dequeue := #dequeue AND NOT #statEdgesMem.dequeue;\n\t    #tempEdges.clear := #clear AND NOT #statEdgesMem.clear;\n\t    // store values for edge detection\n\t    #statEdgesMem.enqueue := #enqueue;\n\t    #statEdgesMem.dequeue := #dequeue;\n\t    #statEdgesMem.clear := #clear;\n\t    \n\t    // This program code section is only executed if no trigger input is active\n\t    IF NOT (#enqueue OR #dequeue OR #reset OR #clear) THEN\n\t        // If an error occurred during program execution,\n\t        // the status \"No Current Job\" is used 16#7000 afterwarts when the triggers are reseted\n\t        #error := false;\n\t        #status := #STATUS_NO_CURRENT_JOBS;\n\t        \n\t        // the program processing OF the FB is terminated\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Validation of inputs\n\t    // check whether the ring #buffer is an ARRAY.\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF IS_ARRAY(#buffer) THEN\n\t        #tempBufferSize := CountOfElements(#buffer);\n\t    ELSE\n\t        #error := true;\n\t        #status := #ERR_NO_ARRAY;\n\t        \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the data type OF the ARRAY elements matches\n\t    // the data type OF the entry (#item). IF the data types DO NOT match,\n\t    // the program execution is terminated at this point\n\t    IF (TypeOf(#item) <> TypeOfElements(#buffer)) THEN\n\t        #error := true;\n\t        #status := #ERR_WRONG_TYPE_ITEM;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the initial value OF the ring #buffer\n\t    // matches the entry (tag #item). IF the data types DO NOT match,\n\t    // the program execution is terminated at this point\n\t    IF (TypeOf(#item) <> TypeOf(#initialItem)) THEN\n\t        #error := true;\n\t        #status := #ERR_WRONG_TYPE_INITIAL_ITEM;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the variable indices are within the ARRAY limits.\n\t    // IF they are NOT, the program execution is terminated at this point\n\t    IF (#statNextEmptyItemIndex >= #tempBufferSize) THEN\n\t        #error := true;\n\t        #status := #ERR_INDEX_IN_ARRAY_LIMITS_1;\n\t        \n\t        RETURN;\n\t    ELSIF (#statFirstItemIndex >= #tempBufferSize) THEN\n\t        #error := true;\n\t        #status := #ERR_INDEX_IN_ARRAY_LIMITS_2;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // If resetBuffer is \"TRUE\", the buffer counters are reset\n\t    IF #reset THEN\n\t        #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t        #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t        #statElementCount := #EMPTY_INITIALIZED;\n\t        #elementCount := #EMPTY_INITIALIZED;\n\t        #isEmpty := true;\n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // If clearBuffer has rising edge, the buffer is initialized by initial values\n\t    IF #tempEdges.clear THEN\n\t        FOR #tempCounter := #COUNTER_LOWER_LIMIT TO UDINT_TO_INT(#tempBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t            \n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #tempCounter,\n\t                                                   DEST => #buffer);\n\t        END_FOR;\n\t        \n\t        // checks whether a local error has occurred.\n\t        IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #error := true;\n\t            #status := #ERR_CLEAR_BUFFER;\n\t           \n\t        END_IF;\n\t        \n\t        // reset counters\n\t        #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t        #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t        #statElementCount := #EMPTY_INITIALIZED;\n\t        #elementCount := #EMPTY_INITIALIZED;\n\t        #isEmpty := true;\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION FIFO algorithm  \n\t    IF #tempEdges.dequeue THEN\n\t        REGION dequeue\n\t            // check whether the ring #buffer is empty\n\t            // IF this is the CASE, program execution is terminated at this point\n\t            IF (#statFirstItemIndex = #BUFFER_IS_EMPTY) THEN\n\t                #error := true;\n\t                #status := #ERR_BUFFER_EMPTY;\n\t               \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // return the first entry of the ring buffer\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #buffer,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #statFirstItemIndex,\n\t                                                   DEST_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST => #item);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_RETURN_FIRST_ENTRY;\n\t               \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // check whether the ring #buffer contains ARRAY elements\n\t            // IF it does, the first entry is passed further on and the index is incremented BY 1\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #statFirstItemIndex,\n\t                                                   DEST => #buffer);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_REPLACE_ITEM_BY_INIT_VALUE;\n\t                \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // calculate the new index of the first entry\n\t            #tempNewFirstItemIndex := #statFirstItemIndex + #INCREMENT;\n\t            #tempNewFirstItemIndex := #tempNewFirstItemIndex MOD UDINT_TO_INT(#tempBufferSize);\n\t            \n\t            // check whether the ring buffer is empty\n\t            IF (#statNextEmptyItemIndex = #tempNewFirstItemIndex) THEN\n\t                // If the ring buffer is empty, the index is set to 0\n\t                #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t                #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t            ELSE\n\t                // The index of the first entry is changed\n\t                #statFirstItemIndex := #tempNewFirstItemIndex;\n\t            END_IF;\n\t            \n\t            // Evaluation of the number of elements in the stack\n\t            #statElementCount -= #INCREMENT;\n\t            \n\t        END_REGION dequeue\n\t        \n\t    ELSIF #tempEdges.enqueue THEN\n\t        REGION enqueue\n\t            // check whether the ring #buffer is full\n\t            // IF this is the CASE, program execution is terminated at this point\n\t            IF (#statNextEmptyItemIndex = #statFirstItemIndex) THEN\n\t                #error := true;\n\t                #status := #ERR_BUFFER_FULL;\n\t             \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // write the entry to the ring buffer\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #item,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #statNextEmptyItemIndex,\n\t                                                   DEST => #buffer);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_WRITE_ENTRY;\n\t             \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // increment the index by 1 and calculates the new empty entry index\n\t            #tempNewNextEmptyItemIndex := (#statNextEmptyItemIndex + #INCREMENT) MOD UDINT_TO_INT(#tempBufferSize);\n\t            #statNextEmptyItemIndex := #tempNewNextEmptyItemIndex;\n\t            \n\t            // check which index the \"#firstItemIndex\" tag has\n\t            // IF the number = -1, the ring buffer is initialized\n\t            // AND the entry is written TO the ring #buffer\n\t            // Therefore, \"0\" must be assigned TO the tag\n\t            IF (#statFirstItemIndex = #BUFFER_INITIALIZED) THEN\n\t                #statFirstItemIndex := #INDEX_BEGINNING;\n\t            END_IF;\n\t            \n\t            // Evaluation of the number of elements in the stack\n\t            #statElementCount += #INCREMENT;\n\t        END_REGION enqueue\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t    #elementCount := #statElementCount;\n\t    #isEmpty := #statElementCount <= #ZERO_ELEMENTS;\n\t    \n\t    #error := false;\n\t    #status := #STATUS_NO_ERROR;\n\t \n\t    // no error handling by ENO needed\n\t    ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK\n\n"
# example 15
requirement: {"title": "计算移动平均值", "description": "编写一个函数块FB，该函数块计算并更新一个移动算术平均值。移动算术平均值是一种在连续数据点上进行平均的方法，其中每个新的数据点都会替换掉最旧的数据点，然后重新计算平均值。\n\n1. cyclicExecution为TRUE时，每个扫描周期自动读取一次新数据value，并更新移动平均值average。\n2. 提供外部触发信号trigger，当触发上升沿时，立即读取一次新数据并更新移动平均值。\n3. 提供复位功能reset，当复位信号为TRUE时，重置移动平均值计算。如果窗口大小小于1或大于100，则输出错误状态和状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：窗口长度设置错误，请设置一个介于1到100之间的值。", "type": "FUNCTION_BLOCK", "name": "FloatingAverage", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "为TRUE时，周期性读取，trigger不起作用"}, {"name": "trigger", "type": "Bool", "description": "外部触发信号，每次上升沿读取value"}, {"name": "value", "type": "LReal", "description": "新读取的数据值"}, {"name": "windowSize", "type": "Int", "description": "移动平均值的窗口大小，要求范围在1到100之间"}, {"name": "reset", "type": "Bool", "description": "复位信号，当为TRUE时重置移动平均值计算"}], "output": [{"name": "average", "type": "LReal", "description": "移动平均值"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE:尚未达到最大窗口宽度 TRUE:已经达到最大窗口宽度"}, {"name": "error", "type": "Bool", "description": "FALSE:没有发生错误 TRUE:执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}]}
SCL CODE: "FUNCTION_BLOCK \"FloatingAverage\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      cyclicExecution : Bool := false;\n      trigger : Bool;\n      value : LReal;\n      windowSize : Int := 100;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      average  : LReal;\n      windowSizeReached  : Bool;\n      error  : Bool;\n      status  : Word;\n   END_VAR\n\n   VAR \n      statValues  : Array[#ZERO_INT..#MAX_WINDOW_SIZE] of LReal;\n      statValuesSum  : LReal := 0.0;\n      statArithmeticAverage  : LReal := 0.0;\n      statWindowSizeOld  : Int := 0;\n      statCounter  : Int := 0;\n      statwindowSizeReached  : Bool;\n      statTriggerOld  : Bool := false;\n   END_VAR\n\n   VAR_TEMP \n      tempValue : LReal;\n      tempIndex : Int;\n      tempTriggerEdge : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_LREAL : LReal := 0.0;\n      MAX_WINDOW_SIZE : Int := 100;\n      INCREMENT : Int := 1;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_WRONG_WINDOW_SIZE : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // Title:            FloatingAverage\n\t  // Comment/Function: This function block calculates the floating arithmetic average\n\t  //                   of incoming REAL values each cycle or each trigger impulse.\n\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Copy commonly used data to temp variables\n\t  #tempValue := #value;\n\t  \n\t  // Positive edge detection for triggering of calculation\n\t  #tempTriggerEdge := #trigger AND NOT #statTriggerOld;\n\t  #statTriggerOld := #trigger;\n\t  \n\t  // Reset OR if window size changes the calculation\n\t  IF #reset OR (#windowSize <> #statWindowSizeOld) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #windowSizeReached := FALSE;\n\t    #statwindowSizeReached := FALSE;\n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    RETURN;\n\t    \n\t    // Check window size, in case of incorrect window size setup an error\n\t  ELSIF (#windowSize <= #ZERO_INT) OR (#windowSize > #MAX_WINDOW_SIZE) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #statwindowSizeReached := FALSE;\n\t    #windowSizeReached := FALSE;\n\t    #error := TRUE;\n\t    #status := #ERR_WRONG_WINDOW_SIZE; // Info \"No correct set of window size\"\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Floating average calculation\n\t  // Triggered calculation OR cyclicly operation\n\t  IF #cyclicExecution OR #tempTriggerEdge THEN\n\t    \n\t    //Calculate array counter by using modulo\n\t    #tempIndex := #statCounter MOD #windowSize;\n\t    \n\t    // First step - fill the Array with values\n\t    // as long as desired window size is not reached\n\t    // counter and array starts with zero\n\t    IF (#statCounter < #windowSize) THEN\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue;\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Increment counter\n\t      #statCounter += #INCREMENT;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #statCounter;\n\t      \n\t    ELSE\n\t      // wuindow size is reached, set output\n\t      #statwindowSizeReached := TRUE;\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue - #statValues[#tempIndex];\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #windowSize;\n\t      \n\t      // Manipulate counter value of window if modulo calc result is zero\n\t      IF (#tempIndex = #ZERO_INT) THEN\n\t        #statCounter := #windowSize + #INCREMENT;\n\t      ELSE\n\t        // Increment counter\n\t        #statCounter += #INCREMENT;\n\t      END_IF;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #average := #statArithmeticAverage;\n\t  #windowSizeReached := #statwindowSizeReached;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  \n\t  // ENO mechanism is not used - forced to true\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n"
# example 16
requirement: {"title": "积分功能", "description": "编写一个函数块FB，该函数块实现输入信号的积分功能，并带有启动和复位功能。积分是对输入信号随时间的累积求和，通常用于计算流量、位移等物理量的累积值。启动功能用于开始积分计算，而复位功能用于将积分值重置为零。\n当读取系统时间出错时，则输出错误状态和错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#8600：读取系统时间错误", "type": "FUNCTION_BLOCK", "name": "Integration", "input": [{"name": "enable", "type": "Bool", "description": "启动信号，当该信号为TRUE时，启用积分计算；如果为FALSE，积分计算将停止，integral输出将显示最后一次计算的值。"}, {"name": "value", "type": "LReal", "description": "需要积分的输入信号值"}, {"name": "reset", "type": "Bool", "description": "复位信号，当该信号为TRUE时，将积分值重置为零"}], "output": [{"name": "integral", "type": "LReal", "description": "积分值"}, {"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}]}
SCL CODE: "FUNCTION_BLOCK \"Integration\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      enable : Bool;\n      value : LReal;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      integral : LReal;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR \n      statLastTime  : DTL;\n      statInputOldValue : LReal;\n      statIntegral : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempSysTime  : DTL;\n      tempTimeDiffrence : LReal;\n      tempCalculation : LReal;\n      tempRetval : Word;\n   END_VAR\n\n   VAR CONSTANT \n      CLEAR_TIME  : DTL;\n      SECOND_IN_MS : LReal := 1000.0;\n      DIVIDE_BY_TWO : LReal := 2.0;\n      ZERO : LReal := 0.0;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_READ_SYS_TIME : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //============================================================================\n\t    // Title:            Integration\n\t    // Comment/Function: Integrates the input value\n\t    //                   integration by trapezoidal rule\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\t//Reset region must be before the enable region so that even if the function disabled, the user can reset the values.\n\tREGION Reset the function\n\t    IF #reset THEN\n\t        #statInputOldValue := #ZERO;\n\t        #statIntegral := #ZERO;\n\t        \n\t        // Clear LastTime value.\n\t        // Initial condition - first Delta time will be 0.\n\t        #statLastTime := #CLEAR_TIME;\n\t        \n\t        #integral := #ZERO;\n\t        #error := false;\n\t        #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t        \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION Reset the function\n\t\n\tREGION Enable/Disable integral calculation\n\t    IF NOT #enable THEN\n\t        #statInputOldValue := #ZERO;\n\t        \n\t        // Clear LastTime value.\n\t        // If it is not cleared when the function is enabled again,\n\t        // the first value will be multiplied with the time difference of the whole disable time\n\t        // Initial condition - first Delta time will be 0.\n\t        #statLastTime := #CLEAR_TIME;\n\t        \n\t        #integral := #statIntegral;\n\t        #error := false;\n\t        #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t        \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION Enable/Disable integral calculation\n\t\n\tREGION Get system time\n\t    // Read system time\n\t    #tempRetval := INT_TO_WORD(RD_SYS_T(OUT => #tempSysTime));\n\t    \n\t    // Error Handling read system time\n\t    IF (#tempRetval > #SUB_STATUS_NO_ERROR) THEN\n\t        #integral := #statIntegral;\n\t        #error := TRUE;\n\t        #status := #ERR_READ_SYS_TIME;\n\t       \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating the integral\n\t    // Calculate time difference between last and actual time\n\t    // coverting from DTL via time and DInt to Real\n\t    // scale from millisecond to second\n\t    #tempTimeDiffrence := DINT_TO_REAL(TIME_TO_DINT(T_DIFF(IN1 := #tempSysTime, IN2 := #statLastTime))) / #SECOND_IN_MS;\n\t    \n\t    // Write actual to last time\n\t    #statLastTime := #tempSysTime;\n\t    \n\t    // integration by trapezoidal rule\n\t    // add LastScalIn to ScalIn\n\t    // divide by two --> avarage of both - old and actual value\n\t    // multiply with time delta --> area unterneath the both borders\n\t    #tempCalculation := (#value + #statInputOldValue) * #tempTimeDiffrence / #DIVIDE_BY_TWO;\n\t    \n\t    // Calculate new integral\n\t    #statIntegral += #tempCalculation;\n\t    \n\t    // Save last input\n\t    #statInputOldValue := #value;\n\tEND_REGION Calculating the integral\n\t\n\tREGION Write outputs\n\t    #integral := #statIntegral;\n\t    #error := false;\n\t    #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t    \n\t    \n\t    //ENO mechanism is not used\n\t    ENO := TRUE;\n\tEND_REGION Write outputs\n\t\nEND_FUNCTION_BLOCK\n\n"
# example 17
requirement: {"title": "灯控程序", "description": "编写一个函数块FB，实现一个灯控功能。\n某控制台有3个指示灯，要求通过3个按钮开关进行控制。\n\n1. 输入参数#button1~#button3表示3个按钮开关，输出参数#greenLight、#redLight、#yellowLight表示指示灯。\n2. 当#button1=0时，表示手动模式，指示灯根据#button2和#button3的操作组合进行不同状态显示：\n   - 当#button2和#button3都为0时，所有指示灯熄灭（#greenLight、#redLight、#yellowLight都为0）。\n   - 当#button2为1且#button3为0时，#greenLight常亮，并且#redLight以0.5Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2为0且#button3为1时，#redLight常亮，并且#yellowLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2和#button3都为1时，#yellowLight常亮，并且#greenLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n3. 当#button1=1时，表示自动模式，指示灯自动按照如下说明循环执行：\n   - 首先#greenLight亮，保持1秒。\n   - 然后#greenLight熄灭，#redLight亮，保持1秒。\n   - 然后#redLight熄灭，#yellowLight亮，保持1秒。\n   - 然后回到初始状态#greenLight亮，保持1秒，如此循环。", "type": "FUNCTION_BLOCK", "name": "LightsControl", "input": [{"name": "button1", "type": "Bool", "description": "按钮1"}, {"name": "button2", "type": "Bool", "description": "按钮2"}, {"name": "button3", "type": "Bool", "description": "按钮3"}], "output": [{"name": "greenLight", "type": "Bool", "description": "绿灯"}, {"name": "redLight", "type": "Bool", "description": "红灯"}, {"name": "yellowLight", "type": "Bool", "description": "黄灯"}]}
SCL CODE: "FUNCTION_BLOCK \"LightsControl\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      button1 : Bool;\n      button2 : Bool;\n      button3 : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      greenLight : Bool;\n      redLight : Bool;\n      yellowLight : Bool;\n   END_VAR\n\n   VAR \n      CycleStep : Int := 0;\n      ManModeTimer1 : TON_TIME;\n      ManModeTimer2 : TON_TIME;\n      AutoModeTimer : TON_TIME;\n   END_VAR\n\n\nBEGIN\n\t    IF #button1 = FALSE THEN\n\t        #ManModeTimer1(IN := #ManModeTimer2.Q,\n\t                       PT := t#1s);\n\t        #ManModeTimer2(IN := NOT #ManModeTimer1.Q,\n\t                       PT := t#1s);\n\t        IF #button2 AND NOT #button3 THEN\n\t            #greenLight := TRUE;\n\t            #redLight := #ManModeTimer2.Q;\n\t            #yellowLight := FALSE;\n\t        ELSIF NOT #button2 AND #button3 THEN\n\t            #redLight := TRUE;\n\t            #yellowLight := #ManModeTimer2.Q;\n\t            #greenLight := FALSE;\n\t        ELSIF #button2 AND #button3 THEN\n\t            #yellowLight := TRUE;\n\t            #greenLight := #ManModeTimer2.Q;\n\t            #redLight := FALSE;\n\t        ELSE\n\t            #greenLight := FALSE;\n\t            #redLight := FALSE;\n\t            #yellowLight := FALSE;\n\t        END_IF;\n\t        \n\t    ELSE\n\t        #AutoModeTimer(IN := TRUE,\n\t                       PT := T#1s);\n\t        CASE #CycleStep OF\n\t            0:\n\t                #greenLight := TRUE;\n\t                #redLight := FALSE;\n\t                #yellowLight := FALSE;\n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 1;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t            1:\n\t                #greenLight := FALSE;\n\t                #redLight := TRUE;\n\t                #yellowLight := FALSE;\n\t                \n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 2;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t            2:\n\t                #greenLight := FALSE;\n\t                #redLight := FALSE;\n\t                #yellowLight := TRUE;\n\t                \n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 0;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t        END_CASE;\n\t    END_IF;\nEND_FUNCTION_BLOCK\n\n"
# example 18
requirement: {"title": "矩阵加法", "description": "编写一个函数FC，实现两个矩阵的加法功能。\n\n该函数接受两个可变长度的二维浮点数数组matrix1和matrix2作为输入参数。函数应检查两个输入矩阵以及用于返回结果的输出矩阵是否具有相同的行数和列数，如果不相同，则返回错误状态和特定的错误代码。\n\n状态代码：\n16#0000：执行FB没有出错\n16#8200：第一矩阵数组行的下界值与第二矩阵行的下界值不同\n16#8201：第一矩阵数组行的下界值与结果矩阵行的下界值不同\n16#8202：第一矩阵数组列的下界值与第二矩阵列的下界值不同\n16#8203：第一矩阵数组列的下界值与结果矩阵列的下界值不同\n16#8204：第一矩阵数组行的上界值与第二矩阵行的上界值不同\n16#8205：第一矩阵数组行的上界值与结果矩阵行的上界值不同\n16#8206：第一矩阵数组列的上界值与第二矩阵列的上界值不同\n16#8207：第一矩阵数组列的上界值与结果矩阵列的上界值不同", "type": "FUNCTION", "name": "MatrixAddition", "input": [{"name": "matrix1", "type": "Array[* *] of LReal", "description": "第一矩阵"}, {"name": "matrix2", "type": "Array[* *] of LReal", "description": "第二矩阵"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in_out": [{"name": "matrixResult", "type": "Array[* *] of LReal", "description": "存放计算结果的矩阵"}]}
SCL CODE: "FUNCTION \"MatrixAddition\" : Void\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      matrix1 : Array[*, *] of LReal;\n      matrix2 : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrixResult : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempMatrix2LowerBoundRows : DInt;\n      tempMatrix2LowerBoundColumns : DInt;\n      tempMatrix2UpperBoundRows : DInt;\n      tempMatrix2UpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempCounterRows : DInt;\n      tempCounterColumns : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS : Word := 16#8200;\n      ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS : Word := 16#8201;\n      ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS : Word := 16#8202;\n      ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS : Word := 16#8203;\n      ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS : Word := 16#8204;\n      ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS : Word := 16#8205;\n      ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS : Word := 16#8206;\n      ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS : Word := 16#8207;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            MatrixAddition\n\t  // Comment/Function: Caluclates the sum of two matrices\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Getting matrices size\n\t  //Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2LowerBoundRows := LOWER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2LowerBoundColumns := LOWER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\t  \n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2UpperBoundRows := UPPER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2UpperBoundColumns := UPPER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error evaluation of matrixes dimentions\n\t  //Check the lower bound of all matrices\n\t  IF (#tempMatrix1LowerBoundRows <> #tempMatrix2LowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundRows <> #tempResultMatrixLowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempMatrix2LowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempResultMatrixLowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\t  //Check the upper bound of all matrices\n\t  IF (#tempMatrix1UpperBoundRows <> #tempMatrix2UpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundRows <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempMatrix2UpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Addition of the matrices and writting to output\n\t  FOR #tempCounterRows := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempCounterColumns := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      #matrixResult[#tempCounterRows, #tempCounterColumns] := #matrix1[#tempCounterRows, #tempCounterColumns] + #matrix2[#tempCounterRows, #tempCounterColumns];\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n"
# example 19
requirement: {"title": "随机数", "description": "编写一个函数FC，该函数使用PLC的时钟值在指定的范围内生成一个随机整数。\n如果指定的范围不正确或读取系统时间出错，则输出错误状态和错误代码。\n\n状态代码\n16#0000：执行FB没有出错\n16#8200：指定的范围不正确：minValue 大于 maxValue\n16#8600：读取系统时间错误", "type": "FUNCTION", "name": "RandomRange_DInt", "input": [{"name": "minValue", "type": "DInt", "description": "随机数范围的最小值"}, {"name": "maxValue", "type": "DInt", "description": "随机数范围的最大值"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "return_value": [{"type": "DInt", "description": "产生的随机数"}]}
SCL CODE: "FUNCTION \"RandomRange_DInt\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      minValue : DInt;\n      maxValue : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime  : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n      tempNormReal : Real;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : DInt := 0;\n      MAX_UDINT : UDInt := 4_294_967_295;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_MAX_LESS_MIN : Word := 16#8200;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //=============================================================================\n\t    // Title:            RandomRange_DInt\n\t    // Comment/Function: This function generates random numbers in defined limits (Datatype DInt)\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Validation\n\t    // Check if the maximal Value is less than the minimal value\n\t    IF (#minValue > #maxValue) THEN\n\t        #error := true;\n\t        #status := #ERR_MAX_LESS_MIN;\n\t        \n\t        #RandomRange_DInt := #ZERO;\n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // Read system time\n\t    #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t    \n\t    // Check return variable for error\n\t    IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t        #error := true;\n\t        #status := #ERR_RD_SYS_T;\n\t        \n\t        #RandomRange_DInt := #ZERO;\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t    // Converting to double word so individual bytes can be addressed\n\t    #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t    \n\t    // Callculate a random-start-value depending on the time\n\t    #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t    #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t    #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t    #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t    \n\t    // Norm the calculated random number: 0.0 <= #tempNormReal <= 1.0\n\t    #tempNormReal := UDINT_TO_REAL(DWORD_TO_UDINT(#tempRandomValue)) / UDINT_TO_REAL(#MAX_UDINT);\n\t    \n\t    // Scale the tempNormReal to be in the range of maxValue and minValue\n\t    #RandomRange_DInt := REAL_TO_DINT((#tempNormReal * DINT_TO_REAL(#maxValue - #minValue) + DINT_TO_REAL(#minValue)));\n\t    \n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    \n\t    // ENO mechanism is not used\n\t    ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n"
# example 20
requirement: {"title": "查找最大最小值", "description": "编写一个函数FC，该函数能够接收一个可变长度的整数数组作为输入，并返回数组中的最大值和最小值以及他们所在数组的位置。\n\n示例：\n假设输入数组为array[1..5]=[5, 10, 2, 25, 1]，函数应返回最大值25，最小值1，最大值所在位置4，最小值所在位置5。", "type": "FUNCTION", "name": "SearchMinMax_DInt", "input": [{"name": "values", "type": "Array[*] of DInt", "description": "待查找的数组"}], "output": [{"name": "minValue", "type": "DInt", "description": "数组中的最小值"}, {"name": "minValueIndex", "type": "DInt", "description": "最小值在数组中的位置"}, {"name": "maxValue", "type": "DInt", "description": "数组中的最大值"}, {"name": "maxValueIndex", "type": "DInt", "description": "最大值在数组中的位置"}]}
SCL CODE: "FUNCTION \"SearchMinMax_DInt\" : Void\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      values : Array[*] of DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      minValue : DInt;\n      minValueIndex : DInt;\n      maxValue : DInt;\n      maxValueIndex : DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayLowerBound : DInt;\n      tempArrayUpperBound : DInt;\n      tempCounter : DInt;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValue : DInt;\n      tempMinValue : DInt;\n      tempMaxValue : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      START_FROM_SECOND_ELEMENT : Int := 1;\n      DIMENSION_ONE : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            SearchMinMax_DInt\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers for\n\t  //                   array of double integers\n\t \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Validation of inputs and outputs \n\t  // Lower bound\n\t  #tempArrayLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t  // Upper bound \n\t  #tempArrayUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\tEND_REGION\n\t\n\tREGION Searching the array \n\t  // Assign first value as min / max\n\t  #tempMinValue := #tempMaxValue := #values[#tempArrayLowerBound];\n\t  #tempArrayIndexMin := #tempArrayIndexMax := #tempArrayLowerBound;\n\t  \n\t  // Search the Array for min/max values\n\t  FOR #tempCounter := (#tempArrayLowerBound + #START_FROM_SECOND_ELEMENT) TO #tempArrayUpperBound DO\n\t    \n\t    #tempActValue := #values[#tempCounter];\n\t    \n\t    // check for min\n\t    IF #tempActValue < #tempMinValue THEN\n\t      #tempMinValue := #tempActValue;\n\t      #tempArrayIndexMin := #tempCounter;\n\t      // check for max\n\t    ELSIF #tempActValue > #tempMaxValue THEN\n\t      #tempMaxValue := #tempActValue;\n\t      #tempArrayIndexMax := #tempCounter;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  // Copy found values to outputs\n\t  // Copy Minimum value\n\t  #minValue := #values[#tempArrayIndexMin];\n\t  // Copy Maximum value\n\t  #maxValue := #values[#tempArrayIndexMax];\n\t  \n\t  // Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  // ENO mechanism is not used, no error possible\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n"
# example 21
requirement: {"title": "生成脉冲信号", "description": "编写一个函数块FB，该函数块生成一个周期性的信号，该信号在FALSE和TRUE之间变化。每个周期中TRUE状态的持续时间和FALSE状态的持续时间由给定的频率和脉冲间歇比决定。脉冲间歇比定义的是每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。\n\n示例：\n假设frequency为0.5Hz，pulsePauseRatio为3。这意味着每个周期是2秒，其中TRUE状态持续1.5秒，FALSE状态持续0.5秒。", "type": "FUNCTION_BLOCK", "name": "Frequency", "input": [{"name": "frequency", "type": "Real", "description": "以Hz为单位的时钟频率"}, {"name": "pulsePauseRatio", "type": "Real", "description": "脉冲间歇比，定义为每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。例如，如果pulsePauseRatio为2，则TRUE状态的持续时间将是FALSE状态的两倍。"}], "output": [{"name": "clock", "type": "Bool", "description": "脉冲输出"}, {"name": "countdown", "type": "Time", "description": "当前状态的剩余时间"}]}
SCL CODE: "FUNCTION_BLOCK \"Frequency\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      frequency : Real := 0.0;\n      pulsePauseRatio : Real := 1.0;\n   END_VAR\n\n   VAR_OUTPUT \n      clock  : Bool;\n      countdown  : Time;\n   END_VAR\n\n   VAR \n      instTofTimePulse  : TOF_TIME;\n      instTofTimePause  : TOF_TIME;\n      statFrequencyOld  : Real;\n      statPulsePauseRatioOld : Real;\n      statTimePulse  : Time;\n      statTimePause  : Time;\n   END_VAR\n\n   VAR_TEMP \n      tempPulseRate : Real;\n      tempPauseRate : Real;\n      tempCountdown : Time;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real := 0.0;\n      ZERO_TIME : Time := T#0ms;\n      SECOND_IN_MS : Real := 1000.0;\n      ONE : Real := 1.0;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            Frequency\n\t  // Comment/Function: This function generates a signal that changes between the values `FALSE` and `TRUE` depending on a defined frequency and a pulse pause ratio.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Calculation of settings and program execution\n\t  // If input <= 0.0 the block is disabled\n\t  IF (#frequency <= #ZERO) OR (#pulsePauseRatio <= #ZERO) THEN\n\t    #clock := FALSE;\n\t    #tempCountdown := #ZERO_TIME;\n\t  ELSE\n\t    \n\t    //Calculating function frequency and pulse pause ratio only when an input is changed\n\t    IF #statFrequencyOld <> #frequency OR #statPulsePauseRatioOld <> #pulsePauseRatio THEN\n\t      RESET_TIMER(TIMER := #instTofTimePause);\n\t      RESET_TIMER(TIMER := #instTofTimePulse);\n\t      \n\t      #tempPulseRate := #pulsePauseRatio / (#pulsePauseRatio + #ONE); // Calculate pulse rate   \n\t      #tempPauseRate := #ONE - #tempPulseRate;                      // Calculate pause rate   \n\t      #statTimePulse := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPulseRate / #frequency))); // Calculate pulse time   \n\t      #statTimePause := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPauseRate / #frequency))); // Calculate pause time\n\t      #statFrequencyOld := #frequency;\n\t      #statPulsePauseRatioOld := #pulsePauseRatio;\n\t    END_IF;\n\t    \n\t    //Two time off-delay timers that are resetting each other on expiration\n\t    #instTofTimePulse(IN := NOT #instTofTimePause.Q,\n\t                      PT := #statTimePulse);\n\t    \n\t    //If timer for pulse is running, remaining time of the PULSE is calculated\n\t    #tempCountdown := #statTimePulse - #instTofTimePulse.ET;\n\t    \n\t    #instTofTimePause(IN := #instTofTimePulse.Q,\n\t                      PT := #statTimePause);\n\t    \n\t    //If timer for pulse is NOT running, remaining time of the PAUSE is calculated\n\t    IF #tempCountdown = #ZERO_TIME THEN\n\t      #tempCountdown := #statTimePause - #instTofTimePause.ET;\n\t    END_IF;\n\t    \n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Assigning value of the pulse timer to the clock output\n\t  #clock := #instTofTimePulse.Q;\n\t  #countdown := #tempCountdown;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n"
# example 22
requirement: {"title": "排序", "description": "编写一个函数块FB，实现一个可选的升序或降序排序功能。该函数块应接受一个可变长度的整数数组（最大长度为1000个元素）以及一个指示排序方向的参数（升序或降序），并将排序后的结果写回到原数组中。如果数组元素超过了1000或不超过1个，函数块应输出一个表示错误的状态和一个错误代码。状态代码：\n16#0000：执行FB没有出错\n16#8200：数组元素没超过1个\n16#8201：数组元素超过了1000个", "type": "FUNCTION_BLOCK", "name": "ShellSort_DInt", "input": [{"name": "sortDirection", "type": "Bool", "description": "当为FALSE时表示升序排列，当为TRUE时表示降序排列"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in_out": [{"name": "array", "type": "Array[*] of DInt", "description": "待排序的数组"}]}
SCL CODE: "FUNCTION_BLOCK \"ShellSort_DInt\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      sortDirection : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status  : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of DInt;\n   END_VAR\n\n   VAR \n      tempArray : Array[1..#MAX_ARRAY_ELEMENTS] of DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempNoOfElements : DInt;\n      tempGap : DInt;\n      tempLoopIndex : DInt;\n      tempExchangeIndex : DInt;\n      tempExchangeVariable : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ARRAY_START_INDEX : UInt := 1;\n      SINGLE_ARRAY_ELEMENT : DInt := 1;\n      GAP_INIT : Int := 1;\n      GAP_THRESHOLD : Int := 1;\n      GAP_RATIO : DInt := 3;\n      INCREMENT : Int := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      MAX_ARRAY_ELEMENTS : Int := 1000;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // Title:            ShellSort_DInt\n\t  // Comment/Function: This block sorts an array with any number of elements (max. 1000)\n\t  //                   in ascending or descending order and returns the sorted version of the array in the same variable.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Special description\n\t  // Space note: If you wish to reduce the space of this block, you may reduce the\n\t  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose\n\t  // It is not recommended to increase the size significantly.\n\tEND_REGION\n\t\n\tREGION Initialization and input data processing\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Shift array index to range 1..MAX_ARRAY_ELEMENTS\n\t  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_TOO_MANY_ELEMENTS;\n\t    RETURN;\n\t  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN\n\t    // If there are 0 elements in the array, set status to \"Error: Parameter is an empty array\"\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Sorting\n\t  // Read the elements of the incoming array and write into the local array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];\n\t  END_FOR;\n\t  \n\t  REGION Shell sort algorithm\n\t    #tempGap := #GAP_INIT;\n\t    \n\t    // Evaluation of the maximal gap size\n\t    REPEAT\n\t      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;\n\t    UNTIL #tempGap > #tempNoOfElements END_REPEAT;\n\t    \n\t    REPEAT\n\t      #tempGap := #tempGap / #GAP_RATIO;\n\t      \n\t      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO\n\t        #tempExchangeVariable := #tempArray[#tempLoopIndex];\n\t        #tempExchangeIndex := #tempLoopIndex;\n\t        \n\t        // sort descending \n\t        IF #sortDirection THEN\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t          \n\t          // sort ascending\n\t        ELSE\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t        END_IF;\n\t        \n\t        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;\n\t      END_FOR;\n\t      \n\t    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;\n\t  END_REGION\n\t  \n\t  // Write the elements of the local array back to the inOut array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];\n\t  END_FOR;\n\t  \n\t  // Set \"No error\" status\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n"
# example 23
requirement: {"title": "特殊堆栈", "description": "编写一个函数块FB，实现一个特殊堆栈功能，在出栈时移除栈内的最小值。\n1. 入栈操作：当新元素入栈时，首先检查栈是否为满。如果栈为满，则不进行任何操作。否则，将其添加到数组的栈顶位置，并更新栈顶位置。\n2. 出栈操作：当执行出栈操作时，首先检查栈是否为空。如果栈为空，则不进行任何操作。否则，移除栈内的最小值，并返回该元素的值，同时更新栈顶位置。\n状态代码：\n16#0000：执行FB没有出错\n16#8A04：堆栈是满的\n16#8A05：堆栈是空的", "type": "FUNCTION_BLOCK", "name": "StackMin", "input": [{"name": "push", "type": "Bool", "description": "入栈操作，在栈未满的情况下，将一个元素添加到栈内"}, {"name": "pop", "type": "Bool", "description": "出栈操作，在栈不空的情况下，从栈内移除最小值元素，并返回该元素的值。"}, {"name": "reset", "type": "Bool", "description": "复位操作，栈顶位置将被重置。"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in_out": [{"name": "item", "type": "Int", "description": "用于入栈或从栈内返回的值"}, {"name": "stack", "type": "Array[0..3] of Int", "description": "用于作为栈的数组"}]}
SCL CODE: "FUNCTION_BLOCK \"StackMin\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      push : Bool;   // 入栈\n      pop : Bool;   // 出栈\n      reset : Bool;   // 复位\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;   // 故障状态\n      status : Word;   // 状态代码\n   END_VAR\n\n   VAR_IN_OUT \n      item : Int;   // 入栈或出栈的元素\n      stack : Array[0..3] of Int;   // 堆栈空间\n   END_VAR\n\n   VAR \n      statStackIndex : Int;   // 堆栈指针\n      statMin : Int;\n   END_VAR\n\n   VAR_TEMP \n      tempStackSize : DInt;\n      tempCount : Int;\n   END_VAR\n\n   VAR CONSTANT \n      STACK_FULL : Word := 16#8A04;   // 堆栈已满\n      STACK_EMPTY : Word := 16#8A05;   // 堆栈已空\n      NO_ERROR : Word := 16#0000;\n   END_VAR\n\n\nBEGIN\n\t//设置堆栈长度\n\tREGION StackSize\n\t    #tempStackSize := 4;\n\tEND_REGION\n\t\n\t//入栈\n\tREGION Push\n\t    IF #push = TRUE THEN\n\t        IF #statStackIndex >= #tempStackSize THEN             //判断是否满栈，如果已经满栈,则不执行入栈,并报错\n\t            #error := TRUE;\n\t            #status := #STACK_FULL;\n\t            RETURN;\n\t        END_IF;\n\t        #stack[#statStackIndex] := #item;                    //否则放入元素\n\t        #statStackIndex += 1;                                //堆栈指针上移\n\t    END_IF;\n\tEND_REGION\n\t\n\t//出栈\n\tREGION Pop\n\t    IF #pop = TRUE THEN\n\t        \n\t        //判断空栈，如果已经空栈,则不执行出栈,并报错\n\t        IF #statStackIndex <= 0 THEN                          \n\t            #error := TRUE;\n\t            #status := #STACK_EMPTY;\n\t            RETURN;\n\t        END_IF;\n\t        \n\t        //查找最小值所在位置\n\t        #statMin := 0;\n\t        IF #statStackIndex>1 THEN\n\t            FOR #tempCount := 1 TO #statStackIndex - 1 DO\n\t                IF #stack[#tempCount] < #stack[#statMin] THEN\n\t                    #statMin := #tempCount;\n\t                END_IF;\n\t            END_FOR;\n\t        END_IF;\n\t        \n\t        //取出元素，上面元素往下顺移\n\t        #item := #stack[#statMin];               \n\t        IF #statMin<>#statStackIndex-1 THEN\n\t            FOR #tempCount := #statMin TO #statStackIndex - 2 DO\n\t                #stack[#tempCount] := #stack[#tempCount + 1];\n\t            END_FOR;\n\t        END_IF;\n\t        #stack[#statStackIndex - 1] := 0;\n\t        #statStackIndex -= 1;                               //堆栈指针下移\n\t    END_IF;\n\tEND_REGION\n\t\n\t//复位\n\tREGION Reset\n\t    IF #reset = TRUE THEN\n\t        #statStackIndex := 0;\n\t    END_IF;\n\tEND_REGION\n\t\n\t#error := FALSE;\n\t#status := #NO_ERROR;\n\t\nEND_FUNCTION_BLOCK\n\n"
# example 24
requirement: {"title": "字符串转换为IP地址和端口号", "description": "在西门子PLC编程中，经常需要从用户输入或外部设备接收包含IP地址和端口号的字符串，并将其解析为相应的整数格式以便进行网络通信。\n编写一个函数FC，用于将包含IP地址和可能包含端口号的字符串转换为整数形式的IP地址和端口号。字符串的格式应为\"xxx.xxx.xxx.xxx[:port]\"，其中xxx代表0-255之间的数字，port代表0-65535之间的端口号（可选）。如果字符串包含端口号，则同时返回端口号；如果不包含，则返回默认的端口号（比如0）。把转换后的IP地址和端口号返回给系统数据类型TADDR_Param结构体的相应位置。\n函数应检查输入字符串是否符合\"IP_ADDRESS:PORT\"的格式要求，其中IP地址由四个用点分隔的0到255之间的整数组成，端口号为一个0到65535之间的整数。\n如果字符串格式正确，函数应将其解析为四个字节的整数数组表示的IP地址和一个整数表示的端口号，并将这些值返回。\n如果字符串格式不正确，函数应输出一个表示错误的状态和一个错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#811x：IP地址含有过多字符，其中x表示出错的最低字节序号，例如，IP地址的第2个字节有错，则x=2\n16#812x：IP地址字符串是空字符串，x表示的含义同上\n16#813x：超过IP地址最大值（255），x表示的含义同上\n16#8150：端口号字符过多\n16#8151：端口号字符串为空\n16#8152：超过端口号最大值（65535）", "type": "FUNCTION", "name": "StringToTaddr", "input": [{"name": "ipAddressString", "type": "String", "description": "输入的字符串"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "return_value": [{"type": "TADDR_Param", "description": "转换后的IP地址和端口号"}]}
SCL CODE: "FUNCTION \"StringToTaddr\" : TADDR_Param\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      ipAddressString : String;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempOctetIndex : Int;\n      tempCharPosition : Int;\n      tempAddressString : String;\n      tempOctetString : String[#MAX_CHAR_FOR_IP_OCTET_NUMBER];\n      tempNumber : UDInt;\n      tempPortNumberIsSpecified : Bool;\n      tempIpAdressTaddr  : TADDR_Param;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_OCTET_WRONG_NUMBER_OF_CHAR : Word := 16#8110;\n      ERR_OCTET_STRING_IS_EMPTY : Word := 16#8120;\n      ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS : Word := 16#8130;\n      ERR_PORT_WRONG_NUMBER_OF_CHAR : Word := 16#8150;\n      ERR_PORT_STRING_IS_EMPTY : Word := 16#8151;\n      ERR_PORT_EXCEEDS_MAX_PORT : Word := 16#8152;\n      MAX_IP_ADDRESS_OCTET_NUMBER : USInt := 255;\n      MAX_PORT_NUMBER : UInt := 65535;\n      EMPTY_STRING : Int := 0;\n      MAX_CHAR_FOR_IP_OCTET_NUMBER : Int := 4;\n      MAX_CHAR_FOR_PORT_NUMBER : Int := 5;\n      INIT_VAL : USInt := 0;\n      NUMBER_OF_IP_OCTETS : Int := 4;\n      CHAR_DOT : Char := '.';\n      CHAR_COLON : Char := ':';\n      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            StringToTaddr\n\t  // Comment/Function: This function converts a string IP Address into TADDR Parameter format.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Initialization\n\t  #tempAddressString := #ipAddressString;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[1] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[2] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[3] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[4] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_PORT_NR := #INIT_VAL;\n\t  #StringToTaddr := #tempIpAdressTaddr;\n\tEND_REGION\n\t\n\tREGION Process Address String  \n\t  REGION Process octests 1-4\n\t    FOR #tempOctetIndex := 1 TO #NUMBER_OF_IP_OCTETS BY 1 DO\n\t      // check if loop has not reached the last octet\n\t      IF #tempOctetIndex < #NUMBER_OF_IP_OCTETS THEN\n\t        // search for dot as octet seperator\n\t        // there has to be a dot present between the octets\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_DOT);\n\t        \n\t      ELSE\n\t        // search for colon as port seperator after the last Octet\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_COLON);\n\t        \n\t        // if colon is present, there is a port number specified / check if Port number added\n\t        #tempPortNumberIsSpecified := (#tempCharPosition > 0);\n\t        \n\t        // if no port is spezified, its just the last octet\n\t        IF NOT #tempPortNumberIsSpecified THEN\n\t          // need to set the char position to the end of string + one for later cobesion and checks\n\t          #tempCharPosition := LEN(#tempAddressString) + 1;\n\t        END_IF;\n\t      END_IF;\n\t      \n\t      REGION Octet conversion\n\t        // check if IP Octet contains more then three digits --> Error\n\t        IF #tempCharPosition > #MAX_CHAR_FOR_IP_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_WRONG_NUMBER_OF_CHAR OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // extract octet string\n\t        #tempOctetString := LEFT(IN := #tempAddressString, L := #tempCharPosition - 1);\n\t        // Check if Octet string is empty --> Error\n\t        IF LEN(#tempOctetString) = #EMPTY_STRING THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_STRING_IS_EMPTY OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // Convert the octet string to numerical value\n\t        STRG_VAL(IN     := #tempOctetString,\n\t                 FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t                 P      := #CONVERT_START_POSITION,\n\t                 OUT    => #tempNumber);\n\t        \n\t        // check if the octet number exeeds the maximum possible range of 255 of USInt --> Error\n\t        IF #tempNumber > #MAX_IP_ADDRESS_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // add address octet to temp address tag\n\t        #tempIpAdressTaddr.REM_IP_ADDR[#tempOctetIndex] := UDINT_TO_USINT(#tempNumber);\n\t        \n\t        // delete octet string from address string\n\t        #tempAddressString := DELETE(IN := #tempAddressString, P := 1, L := #tempCharPosition);\n\t      END_REGION Octet conversion\n\t    END_FOR;\n\t  END_REGION Process octests 1-4\n\t  \n\t  REGION PORT number conversion\n\t    // If the string contains a port number too, parse it\n\t    IF #tempPortNumberIsSpecified THEN\n\t      // lenght of string exceeds length of port string --> Error\n\t      IF LEN(#tempAddressString) > #MAX_CHAR_FOR_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_WRONG_NUMBER_OF_CHAR;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t        \n\t        // Check if string is empty --> Error\n\t      ELSIF LEN(#tempAddressString) = #EMPTY_STRING THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_STRING_IS_EMPTY;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // Convert the port number string to numerical value\n\t      STRG_VAL(IN     := #tempAddressString,\n\t               FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t               P      := #CONVERT_START_POSITION,\n\t               OUT    => #tempNumber);\n\t      \n\t      // check if the Port number exeeds the maximum possible range of 65535 of UInt --> Error\n\t      IF #tempNumber > #MAX_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_EXCEEDS_MAX_PORT;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // add port number to temp address tag\n\t      #tempIpAdressTaddr.REM_PORT_NR := UDINT_TO_UINT(#tempNumber);\n\t    END_IF;\n\t  END_REGION PORT number conversion\n\t  \n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #StringToTaddr := #tempIpAdressTaddr;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n"
# example 25
requirement: {"title": "温度逻辑控制", "description": "编写一个函数块FB，实现一个温度控制逻辑。该程序应包含以下功能：\n1. 通过模拟量输入模块读取温度传感器的值。\n2. 将读取的温度值TemperatureSensorInput与设定的温度值SetTemperature进行比较。\n3. 如果实际温度低于设定温度，则启动加热器HeaterOutput。\n4. 如果实际温度高于设定温度，则关闭加热器HeaterOutput。\n5. 如果加热器连续工作超过一定时间（为方便测试，采用5s），应触发过热保护，自动关闭加热器，必须再过一定时间（为方便测试，采用3s）才能解除过热保护。\n6. 提供状态指示，显示当前温度、设定温度、加热器状态以及是否有过热保护触发。\n7. 提供温度传感器故障判断，如果读取的温度值TemperatureSensorInput小于0或大于100，则认为传感器故障，此时应关闭加热器。", "type": "FUNCTION_BLOCK", "name": "TempCtrl", "input": [{"name": "TemperatureSensorInput", "type": "Real", "description": "温度传感器输入值，即实际温度"}, {"name": "SetTemperature", "type": "Real", "description": "设定温度值"}], "output": [{"name": "CurrentTemperature", "type": "Real", "description": "当前温度显示"}, {"name": "SetTempDisplay", "type": "Real", "description": "设定温度显示"}, {"name": "HeaterStatus", "type": "Bool", "description": "加热器状态显示"}, {"name": "OverheatProtection", "type": "Bool", "description": "过热保护状态显示"}], "in_out": [{"name": "HeaterOutput", "type": "Bool", "description": "加热器控制输出"}]}
SCL CODE: "FUNCTION_BLOCK \"TempCtrl\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      TemperatureSensorInput : Real;   // 温度传感器输入值\n      SetTemperature : Real;   // 设定温度值\n   END_VAR\n\n   VAR_OUTPUT \n      CurrentTemperature : Real;   // 当前温度显示\n      SetTempDisplay : Real;   // 设定温度显示\n      HeaterStatus : Bool;   // 加热器状态显示\n      OverheatProtection : Bool;   // 过热保护状态显示\n   END_VAR\n\n   VAR_IN_OUT \n      HeaterOutput : Bool;   // 加热器控制输出\n   END_VAR\n\n   VAR \n      HeaterState : Struct\n         IsEnabled : Bool;\n         OverheatProtectionTriggered : Bool;\n      END_STRUCT;\n      OverheatTimer  : TON_TIME;   // 过热保护定时器\n      SensorError : Bool;   // 传感器错误标志\n      CoolTimer  : TON_TIME;\n      OverheatTimerOutput  : Bool;\n      CoolTimerOutput  : Bool;\n   END_VAR\n\n\nBEGIN\n\t// 显示当前温度和设定温度 \n\t#CurrentTemperature := #TemperatureSensorInput;\n\t#SetTempDisplay := #SetTemperature;\n\t\n\t// 检查传感器是否失效 \n\tIF #TemperatureSensorInput < 0 OR #TemperatureSensorInput > 100 THEN\n\t    #SensorError := TRUE;\n\tELSE\n\t    #SensorError := FALSE;\n\tEND_IF;\n\t\n\t// 温度控制逻辑 \n\t// 过热保护逻辑 \n\t#OverheatTimer(IN := #HeaterOutput,\n\t               PT := T#5S,\n\t               Q => #OverheatTimerOutput);\n\tIF #HeaterState.IsEnabled AND #OverheatTimerOutput THEN\n\t    #HeaterState.OverheatProtectionTriggered := TRUE;\n\t    #HeaterState.IsEnabled := FALSE;\n\t    #HeaterOutput := FALSE;\n\tEND_IF;\n\t#CoolTimer(IN := #HeaterState.OverheatProtectionTriggered,\n\t           PT := t#3S,\n\t           Q => #CoolTimerOutput);\n\tIF #CoolTimerOutput THEN\n\t    #HeaterState.OverheatProtectionTriggered := FALSE ;\n\tEND_IF;\n\t\n\tIF NOT #SensorError THEN\n\t    IF #CurrentTemperature < #SetTemperature AND NOT #HeaterState.OverheatProtectionTriggered THEN\n\t        IF NOT #HeaterState.IsEnabled THEN\n\t            #HeaterState.IsEnabled := TRUE;\n\t            #HeaterOutput := TRUE;\n\t        END_IF;\n\t    ELSIF #CurrentTemperature > #SetTemperature THEN\n\t        IF #HeaterState.IsEnabled THEN\n\t            #HeaterState.IsEnabled := FALSE;\n\t            #HeaterOutput := FALSE;\n\t        END_IF;\n\t    END_IF;\n\t    \n\tELSE\n\t    // 传感器错误处理 \n\t    #HeaterOutput := FALSE;\n\t    #HeaterState.IsEnabled := FALSE;\n\tEND_IF;\n\t\n\t// 显示加热器状态和过热保护状态 \n\t#HeaterStatus := #HeaterState.IsEnabled;\n\t#OverheatProtection := #HeaterState.OverheatProtectionTriggered;\nEND_FUNCTION_BLOCK\n\n"
